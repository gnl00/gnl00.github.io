import{_ as s,o as n,c as a,Q as l}from"./chunks/framework.b41230ea.js";const p="/assets/19.cdbe2072.png",F=JSON.parse('{"title":"Kafka Source","description":"Kafka 源码深入","frontmatter":{"description":"Kafka 源码深入","tag":["Kafka","MQ","中间件"]},"headers":[],"relativePath":"posts/mw/Kafka/KafkaSource.md","filePath":"posts/mw/Kafka/KafkaSource.md","lastUpdated":1700657743000}'),o={name:"posts/mw/Kafka/KafkaSource.md"},e=l('<h1 id="kafka-source" tabindex="-1">Kafka Source <a class="header-anchor" href="#kafka-source" aria-label="Permalink to &quot;Kafka Source&quot;">​</a></h1><h2 id="消息生产" tabindex="-1">消息生产 <a class="header-anchor" href="#消息生产" aria-label="Permalink to &quot;消息生产&quot;">​</a></h2><h3 id="消息生产模型" tabindex="-1">消息生产模型 <a class="header-anchor" href="#消息生产模型" aria-label="Permalink to &quot;消息生产模型&quot;">​</a></h3><p>Kafka 的生产者发送消息采用的是异步发送的方式。在消息发送的过程中，涉及到了两个线程：main 线程和 Sender 线程，以及一个线程共享变量 RecordAccumulator。</p><p>main 线程将消息发送给 RecordAccumulator；Sender 线程不断从 RecordAccumulator 中拉取消息发送到 Broker。</p><p><img src="'+p+`" alt="生产者api调用流程"></p><p><strong>相关参数</strong></p><ul><li><code>batch.size</code> 数据积累到 <code>batch.size</code> 之后， Sender 才会发送数据</li><li><code>linger.ms</code> 如果数据迟迟未达到 <code>batch.size</code>， Sender 等待 <code>linger.time</code> 后发送数据</li></ul><br><h3 id="kafkaproducer" tabindex="-1">KafkaProducer <a class="header-anchor" href="#kafkaproducer" aria-label="Permalink to &quot;KafkaProducer&quot;">​</a></h3><blockquote><p>同步和异步发送都是调用 KafkaProducer#doSend 方法，同步发送 callback=null</p></blockquote><p><strong>发送流程</strong></p><p>1、将信息包装成 AppendCallbacks（其中包含消息记录，消息拦截器，异步回调方法）</p><p>2、如果生产者已经关闭则发送失败，否则继续发送</p><p>3、从 Blocker 集群上获取元数据，包括主题和分区数据</p><p>4、使用指定的序列化器对消息 key 和 value 进行序列化</p><p>5、计算消息发送的目标分区，如果返回值为 RecordMetadata.UNKNOWN_PARTITION，则 RecordAccumulator 会根据内部逻辑选择分区</p><p>6、设置消息属性，计算消息序列化之后的大小</p><p>7、将消息和目标分区包装成 RecordAccumulator.RecordAppendResult</p><p>8、如果自定义分区器存在，则尝试利用 onNewBatch 方法得到新的批次</p><p>9、将记录添加到缓冲器中</p><p>10、如果添加记录后批次已满，或者已创建新批次，则唤醒 sender 线程进行数据发送</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Future</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">RecordMetadata</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">send</span><span style="color:#E1E4E8;">(ProducerRecord</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">K, V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> record, Callback callback) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// intercept the record, which can be potentially modified; this method does not throw exceptions</span></span>
<span class="line"><span style="color:#E1E4E8;">    ProducerRecord&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; interceptedRecord </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.interceptors.</span><span style="color:#B392F0;">onSend</span><span style="color:#E1E4E8;">(record);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doSend</span><span style="color:#E1E4E8;">(interceptedRecord, callback);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 同步调用的是异步发送方法，只是 callback=null</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> Future</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">RecordMetadata</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doSend</span><span style="color:#E1E4E8;">(ProducerRecord</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">K, V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> record, Callback callback) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将信息包装成 AppendCallbacks（其中包含消息记录，消息拦截器，异步回调方法）</span></span>
<span class="line"><span style="color:#E1E4E8;">    AppendCallbacks&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; appendCallbacks </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> AppendCallbacks&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt;(callback, </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.interceptors, record);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">// 检查 Producer 是否已关闭，如果没有关闭，则继续执行该方法</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">throwIfProducerClosed</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// first make sure the metadata for the topic is available</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 从 Broker 上获取指定主题和分区的元数据</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 获取集群信息</span></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">// 将消息序列化</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">// 尝试计算分区，如果返回值为 RecordMetadata.UNKNOWN_PARTITION，</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 设置消息属性与消息头</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 获取序列化消息大小</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">// 判断是否是自定义分区。如果是可以调用 onNewBatch 回调函数</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">// 将消息和 partition 包装成 RecordAccumulator</span></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">// 如果自定义分区器存在，获取分区</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 包装分区</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">// 如果消息批次满了，或者新批次创建</span></span>
<span class="line"><span style="color:#E1E4E8;">      	</span><span style="color:#6A737D;">// 唤醒发送线程，发送消息</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (result.batchIsFull </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> result.</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;">BatchCreated) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            log.</span><span style="color:#B392F0;">trace</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Waking up the sender since topic {} partition {} is either full or getting a new batch&quot;</span><span style="color:#E1E4E8;">, record.</span><span style="color:#B392F0;">topic</span><span style="color:#E1E4E8;">(), appendCallbacks.</span><span style="color:#B392F0;">getPartition</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">          	</span><span style="color:#6A737D;">// public class Sender implements Runnable</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.sender.</span><span style="color:#B392F0;">wakeup</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> result.future;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// handling exceptions and record the errors;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// for API exceptions return them in the future,</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// for other exceptions throw directly</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Future</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">RecordMetadata</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">send</span><span style="color:#24292E;">(ProducerRecord</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">K, V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> record, Callback callback) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// intercept the record, which can be potentially modified; this method does not throw exceptions</span></span>
<span class="line"><span style="color:#24292E;">    ProducerRecord&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; interceptedRecord </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.interceptors.</span><span style="color:#6F42C1;">onSend</span><span style="color:#24292E;">(record);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doSend</span><span style="color:#24292E;">(interceptedRecord, callback);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 同步调用的是异步发送方法，只是 callback=null</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Future</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">RecordMetadata</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doSend</span><span style="color:#24292E;">(ProducerRecord</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">K, V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> record, Callback callback) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将信息包装成 AppendCallbacks（其中包含消息记录，消息拦截器，异步回调方法）</span></span>
<span class="line"><span style="color:#24292E;">    AppendCallbacks&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; appendCallbacks </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> AppendCallbacks&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt;(callback, </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.interceptors, record);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">// 检查 Producer 是否已关闭，如果没有关闭，则继续执行该方法</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">throwIfProducerClosed</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// first make sure the metadata for the topic is available</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 从 Broker 上获取指定主题和分区的元数据</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 获取集群信息</span></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">// 将消息序列化</span></span>
<span class="line"><span style="color:#24292E;">        </span></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">// 尝试计算分区，如果返回值为 RecordMetadata.UNKNOWN_PARTITION，</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 设置消息属性与消息头</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 获取序列化消息大小</span></span>
<span class="line"><span style="color:#24292E;">      </span></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">// 判断是否是自定义分区。如果是可以调用 onNewBatch 回调函数</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">// 将消息和 partition 包装成 RecordAccumulator</span></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">// 如果自定义分区器存在，获取分区</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 包装分区</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">// 如果消息批次满了，或者新批次创建</span></span>
<span class="line"><span style="color:#24292E;">      	</span><span style="color:#6A737D;">// 唤醒发送线程，发送消息</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (result.batchIsFull </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> result.</span><span style="color:#D73A49;">new</span><span style="color:#24292E;">BatchCreated) {</span></span>
<span class="line"><span style="color:#24292E;">            log.</span><span style="color:#6F42C1;">trace</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;Waking up the sender since topic {} partition {} is either full or getting a new batch&quot;</span><span style="color:#24292E;">, record.</span><span style="color:#6F42C1;">topic</span><span style="color:#24292E;">(), appendCallbacks.</span><span style="color:#6F42C1;">getPartition</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">          	</span><span style="color:#6A737D;">// public class Sender implements Runnable</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.sender.</span><span style="color:#6F42C1;">wakeup</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> result.future;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// handling exceptions and record the errors;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// for API exceptions return them in the future,</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// for other exceptions throw directly</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="sender" tabindex="-1">Sender <a class="header-anchor" href="#sender" aria-label="Permalink to &quot;Sender&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">run</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// main loop, runs until close is called</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">runOnce</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#6A737D;">/**...**/</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">run</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// main loop, runs until close is called</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">runOnce</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#6A737D;">/**...**/</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">runOnce</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (transactionManager </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) { </span><span style="color:#6A737D;">/** 如果事务管理器存在 **/</span><span style="color:#E1E4E8;"> }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> pollTimeout </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">sendProducerData</span><span style="color:#E1E4E8;">(currentTimeMs);</span></span>
<span class="line"><span style="color:#E1E4E8;">    client.</span><span style="color:#B392F0;">poll</span><span style="color:#E1E4E8;">(pollTimeout, currentTimeMs);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">runOnce</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (transactionManager </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">/** 如果事务管理器存在 **/</span><span style="color:#24292E;"> }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> pollTimeout </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">sendProducerData</span><span style="color:#24292E;">(currentTimeMs);</span></span>
<span class="line"><span style="color:#24292E;">    client.</span><span style="color:#6F42C1;">poll</span><span style="color:#24292E;">(pollTimeout, currentTimeMs);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">sendProducerData</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> now) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Cluster cluster </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> metadata.</span><span style="color:#B392F0;">fetch</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 获取 Broker 集群信息</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 获取准备发送数据的分区列表</span></span>
<span class="line"><span style="color:#E1E4E8;">    RecordAccumulator.ReadyCheckResult result </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.accumulator.</span><span style="color:#B392F0;">ready</span><span style="color:#E1E4E8;">(cluster, now);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// if there are any partitions whose leaders are not known yet, force metadata update</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// remove any nodes we aren&#39;t ready to send to</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// create produce requests</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// Reset the producer id if an expired batch has previously been sent to the broker. </span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">// 如果有任何准备发送的节点+有可发送的数据，就用 0 超时轮询</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">result.readyNodes.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">()) {ç</span></span>
<span class="line"><span style="color:#E1E4E8;">        pollTimeout </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">sendProduceRequests</span><span style="color:#E1E4E8;">(batches, now);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> pollTimeout;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">sendProducerData</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> now) {</span></span>
<span class="line"><span style="color:#24292E;">    Cluster cluster </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> metadata.</span><span style="color:#6F42C1;">fetch</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 获取 Broker 集群信息</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 获取准备发送数据的分区列表</span></span>
<span class="line"><span style="color:#24292E;">    RecordAccumulator.ReadyCheckResult result </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.accumulator.</span><span style="color:#6F42C1;">ready</span><span style="color:#24292E;">(cluster, now);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// if there are any partitions whose leaders are not known yet, force metadata update</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// remove any nodes we aren&#39;t ready to send to</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// create produce requests</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// Reset the producer id if an expired batch has previously been sent to the broker. </span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">// 如果有任何准备发送的节点+有可发送的数据，就用 0 超时轮询</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">result.readyNodes.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">()) {ç</span></span>
<span class="line"><span style="color:#24292E;">        pollTimeout </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">sendProduceRequests</span><span style="color:#24292E;">(batches, now);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> pollTimeout;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">sendProduceRequest</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> now, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> destination, </span><span style="color:#F97583;">short</span><span style="color:#E1E4E8;"> acks, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> timeout, List</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">ProducerBatch</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> batches) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Map&lt;</span><span style="color:#F97583;">TopicPartition</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">ProducerBatch</span><span style="color:#E1E4E8;">&gt; recordsByPartition </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> HashMap&lt;&gt;(batches.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 进行 Kafka 新旧版本消息兼容操作</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 检查是否是事务消息，设置事务 Id</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// build request</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    String nodeId </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Integer.</span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;">(destination);</span></span>
<span class="line"><span style="color:#E1E4E8;">    ClientRequest clientRequest </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> client.</span><span style="color:#B392F0;">newClientRequest</span><span style="color:#E1E4E8;">(nodeId, requestBuilder, now, acks </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">            requestTimeoutMs, callback);</span></span>
<span class="line"><span style="color:#E1E4E8;">    client.</span><span style="color:#B392F0;">send</span><span style="color:#E1E4E8;">(clientRequest, now);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">sendProduceRequest</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> now, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> destination, </span><span style="color:#D73A49;">short</span><span style="color:#24292E;"> acks, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> timeout, List</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">ProducerBatch</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> batches) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Map&lt;</span><span style="color:#D73A49;">TopicPartition</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">ProducerBatch</span><span style="color:#24292E;">&gt; recordsByPartition </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> HashMap&lt;&gt;(batches.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">());</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 进行 Kafka 新旧版本消息兼容操作</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 检查是否是事务消息，设置事务 Id</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// build request</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    String nodeId </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Integer.</span><span style="color:#6F42C1;">toString</span><span style="color:#24292E;">(destination);</span></span>
<span class="line"><span style="color:#24292E;">    ClientRequest clientRequest </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> client.</span><span style="color:#6F42C1;">newClientRequest</span><span style="color:#24292E;">(nodeId, requestBuilder, now, acks </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">            requestTimeoutMs, callback);</span></span>
<span class="line"><span style="color:#24292E;">    client.</span><span style="color:#6F42C1;">send</span><span style="color:#24292E;">(clientRequest, now);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="networkclient-dosend" tabindex="-1">NetworkClient#doSend <a class="header-anchor" href="#networkclient-dosend" aria-label="Permalink to &quot;NetworkClient#doSend&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doSend</span><span style="color:#E1E4E8;">(</span><span style="color:#6A737D;">/**...**/</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">/**...**/</span></span>
<span class="line"><span style="color:#E1E4E8;">    selector.</span><span style="color:#B392F0;">send</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">NetworkSend</span><span style="color:#E1E4E8;">(clientRequest.</span><span style="color:#B392F0;">destination</span><span style="color:#E1E4E8;">(), send));</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doSend</span><span style="color:#24292E;">(</span><span style="color:#6A737D;">/**...**/</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">/**...**/</span></span>
<span class="line"><span style="color:#24292E;">    selector.</span><span style="color:#6F42C1;">send</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">NetworkSend</span><span style="color:#24292E;">(clientRequest.</span><span style="color:#6F42C1;">destination</span><span style="color:#24292E;">(), send));</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="selector-send" tabindex="-1">Selector#send <a class="header-anchor" href="#selector-send" aria-label="Permalink to &quot;Selector#send&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">send</span><span style="color:#E1E4E8;">(NetworkSend send) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">/**...**/</span></span>
<span class="line"><span style="color:#E1E4E8;">  	channel.</span><span style="color:#B392F0;">setSend</span><span style="color:#E1E4E8;">(send);</span></span>
<span class="line"><span style="color:#E1E4E8;">  	</span><span style="color:#6A737D;">/**...**/</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">send</span><span style="color:#24292E;">(NetworkSend send) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">/**...**/</span></span>
<span class="line"><span style="color:#24292E;">  	channel.</span><span style="color:#6F42C1;">setSend</span><span style="color:#24292E;">(send);</span></span>
<span class="line"><span style="color:#24292E;">  	</span><span style="color:#6A737D;">/**...**/</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="kafkachannel-setsend" tabindex="-1">KafkaChannel#setSend <a class="header-anchor" href="#kafkachannel-setsend" aria-label="Permalink to &quot;KafkaChannel#setSend&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setSend</span><span style="color:#E1E4E8;">(NetworkSend send) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.send </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> send;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.transportLayer.</span><span style="color:#B392F0;">addInterestOps</span><span style="color:#E1E4E8;">(SelectionKey.OP_WRITE); </span><span style="color:#6A737D;">// 设置感兴趣的事件</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setSend</span><span style="color:#24292E;">(NetworkSend send) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.send </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> send;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.transportLayer.</span><span style="color:#6F42C1;">addInterestOps</span><span style="color:#24292E;">(SelectionKey.OP_WRITE); </span><span style="color:#6A737D;">// 设置感兴趣的事件</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><br><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><blockquote><p>和 RocketMQ 的发送流程对比：</p><ul><li><p>发送方式</p><p>Kafka 借助了 nio 来进行消息发送，而 RocketMQ 则是借助 Netty 来实现消息发送。Netty 本质上也是 nio，只是对 nio 的进一步抽象，并提供一组更加易用的 API 操作。</p></li><li><p>发送线程</p><p>Kafka 的发送操作涉及到两个线程一个 main 和一个 Sender 线程；RocketMQ 只有在发送异步消息的时候才涉及到多个线程。</p></li></ul></blockquote><br><h2 id="消息消费" tabindex="-1">消息消费 <a class="header-anchor" href="#消息消费" aria-label="Permalink to &quot;消息消费&quot;">​</a></h2><p>Kafka 的消费者均派生自 Consumer 接口。Consumer 接口预定义了一系列方法：</p><ul><li>subscription() Get the current subscription</li><li>subscribe() Subscribe to the given list of topics to get dynamically assigned partitions</li><li>assignment() Get the set of partitions currently assigned to this consumer</li><li>poll() Fetch data for the topics or partitions specified using one of the subscribe/assign APIs 轮询拉取消息</li><li>commitSync() Commit offsets returned on the last poll() for all the subscribed list of topics and partitions</li><li>commitAsync() Commit offsets returned on the last poll(Duration) for all the subscribed list of topics and partition</li><li>...</li></ul><br><h3 id="消息消费过程" tabindex="-1">消息消费过程 <a class="header-anchor" href="#消息消费过程" aria-label="Permalink to &quot;消息消费过程&quot;">​</a></h3><p>1、Consumer#subscribe 绑定订阅关系</p><p>2、Consumer#poll 消费者按照指定时间，轮询从指定主题或分区上获取数据，再依次消费</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 订阅模式，设置订阅的 topic</span></span>
<span class="line"><span style="color:#E1E4E8;">consumer.</span><span style="color:#B392F0;">subscribe</span><span style="color:#E1E4E8;">(Arrays.</span><span style="color:#B392F0;">asList</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;topic-test&quot;</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (</span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ConsumerRecords&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; records </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> consumer.</span><span style="color:#B392F0;">poll</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">100</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (ConsumerRecord&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; record </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> records) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;[received]: &quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> record);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 订阅模式，设置订阅的 topic</span></span>
<span class="line"><span style="color:#24292E;">consumer.</span><span style="color:#6F42C1;">subscribe</span><span style="color:#24292E;">(Arrays.</span><span style="color:#6F42C1;">asList</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;topic-test&quot;</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (</span><span style="color:#005CC5;">true</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    ConsumerRecords&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; records </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> consumer.</span><span style="color:#6F42C1;">poll</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">100</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (ConsumerRecord&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; record </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> records) {</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;[received]: &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> record);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="kafkaconsumer-poll" tabindex="-1">KafkaConsumer#poll <a class="header-anchor" href="#kafkaconsumer-poll" aria-label="Permalink to &quot;KafkaConsumer#poll&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> ConsumerRecords</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">K, V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">poll</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Timer timer, </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> includeMetadataInTimeout) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 确保消费者处于开启状态</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// if subscriptions.hasNoSubscriptionOrUserAssignment() -&gt; Exception</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">do</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// client.maybeTriggerWakeup(); try to wake up comsumer</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Fetch&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; fetch </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">pollForFetches</span><span style="color:#E1E4E8;">(timer);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">fetch.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 如果有网络问题，尽已经获取到的数据尽可能传输出去</span></span>
<span class="line"><span style="color:#E1E4E8;">              	</span><span style="color:#6A737D;">// 传输到哪里？</span></span>
<span class="line"><span style="color:#E1E4E8;">              	</span><span style="color:#6A737D;">// 源码内发现是将接收到的消息再发送回 Broker</span></span>
<span class="line"><span style="color:#E1E4E8;">              	</span><span style="color:#6A737D;">// 很容易理解，消息接收过程因为网络问题可能未接收完毕，消费操作无法顺利完成。</span></span>
<span class="line"><span style="color:#E1E4E8;">              	</span><span style="color:#6A737D;">// 为了保证消息消费完整性索性将接收到的消息再发送回 Broker，下一次再拉取消费，								// 能保证消息不会丢失</span></span>
<span class="line"><span style="color:#E1E4E8;">              	</span><span style="color:#6A737D;">// 这样子能保证消息至少被消费一次 at least once，消费端再使用一些记录操作</span></span>
<span class="line"><span style="color:#E1E4E8;">              	</span><span style="color:#6A737D;">// 保存已经消费过的消息 id，就能保证消息不重复消费。</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (fetcher.</span><span style="color:#B392F0;">sendFetches</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> client.</span><span style="color:#B392F0;">hasPendingRequests</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    client.</span><span style="color:#B392F0;">transmitSends</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// if (fetch.records().isEmpty())</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.interceptors.</span><span style="color:#B392F0;">onConsume</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ConsumerRecords&lt;&gt;(fetch.</span><span style="color:#B392F0;">records</span><span style="color:#E1E4E8;">())); </span><span style="color:#6A737D;">// 消息消费拦截器生效，再返回拦截器处理过的消息 ConsumerRecords</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (timer.</span><span style="color:#B392F0;">notExpired</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ConsumerRecords.</span><span style="color:#B392F0;">empty</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> ConsumerRecords</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">K, V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">poll</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Timer timer, </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> includeMetadataInTimeout) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 确保消费者处于开启状态</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// if subscriptions.hasNoSubscriptionOrUserAssignment() -&gt; Exception</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">do</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// client.maybeTriggerWakeup(); try to wake up comsumer</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Fetch&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; fetch </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">pollForFetches</span><span style="color:#24292E;">(timer);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">fetch.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 如果有网络问题，尽已经获取到的数据尽可能传输出去</span></span>
<span class="line"><span style="color:#24292E;">              	</span><span style="color:#6A737D;">// 传输到哪里？</span></span>
<span class="line"><span style="color:#24292E;">              	</span><span style="color:#6A737D;">// 源码内发现是将接收到的消息再发送回 Broker</span></span>
<span class="line"><span style="color:#24292E;">              	</span><span style="color:#6A737D;">// 很容易理解，消息接收过程因为网络问题可能未接收完毕，消费操作无法顺利完成。</span></span>
<span class="line"><span style="color:#24292E;">              	</span><span style="color:#6A737D;">// 为了保证消息消费完整性索性将接收到的消息再发送回 Broker，下一次再拉取消费，								// 能保证消息不会丢失</span></span>
<span class="line"><span style="color:#24292E;">              	</span><span style="color:#6A737D;">// 这样子能保证消息至少被消费一次 at least once，消费端再使用一些记录操作</span></span>
<span class="line"><span style="color:#24292E;">              	</span><span style="color:#6A737D;">// 保存已经消费过的消息 id，就能保证消息不重复消费。</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (fetcher.</span><span style="color:#6F42C1;">sendFetches</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> client.</span><span style="color:#6F42C1;">hasPendingRequests</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">                    client.</span><span style="color:#6F42C1;">transmitSends</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// if (fetch.records().isEmpty())</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.interceptors.</span><span style="color:#6F42C1;">onConsume</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ConsumerRecords&lt;&gt;(fetch.</span><span style="color:#6F42C1;">records</span><span style="color:#24292E;">())); </span><span style="color:#6A737D;">// 消息消费拦截器生效，再返回拦截器处理过的消息 ConsumerRecords</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (timer.</span><span style="color:#6F42C1;">notExpired</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ConsumerRecords.</span><span style="color:#6F42C1;">empty</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div>`,48),t=[e];function c(r,E,y,i,d,u){return n(),a("div",null,t)}const A=s(o,[["render",c]]);export{F as __pageData,A as default};
