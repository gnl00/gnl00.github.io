import{_ as a,o as t,c as o,Q as e}from"./chunks/framework.b41230ea.js";const u=JSON.parse('{"title":"常见算法","description":"常见算法思想汇总；分治、动态规划、贪心、回溯、分支界限","frontmatter":{"tag":"算法","description":"常见算法思想汇总；分治、动态规划、贪心、回溯、分支界限"},"headers":[],"relativePath":"posts/algorithm/常见算法.md","filePath":"posts/algorithm/常见算法.md","lastUpdated":1700722361000}'),l={name:"posts/algorithm/常见算法.md"},r=e('<h1 id="常见算法" tabindex="-1">常见算法 <a class="header-anchor" href="#常见算法" aria-label="Permalink to &quot;常见算法&quot;">​</a></h1><br><h2 id="分治" tabindex="-1">分治 <a class="header-anchor" href="#分治" aria-label="Permalink to &quot;分治&quot;">​</a></h2><p>将一个复杂的问题分解成 n 个小问题，并且要求小问题的解法和大问题的解法一致，从而将大问题分而治之。<strong>分治是思想，递归是手段</strong>。分治和递归经常放在一起使用。</p><p>如果一个复杂问题具有以下几个特征：</p><ol><li>该问题缩小到一定规模后就可以很容易解决；</li><li>该问题可以分解成若干个解法一致的小问题；</li><li>该问题的结果可以由若干个小问题的结果合并而成；</li><li>若干个小问题之间相互独立，任意子问题之间没有交集解；</li></ol><p>第一个特征几乎所有的复杂问题都符合；第二个特征也是几乎所有的问题都符合，它是分治法中运用递归手段的前提；第三个特征是关键，能否利用分治法取决于第三个特征，如果具备一和二，不具备三，可以考虑使用动态规划或者贪心算法；第四个特征涉及到分治法的效率问题，如果子问题之间不相互独立，分治法还需要处理重复解，多做了一部分工作。此时虽然可以用分治法，但还是使用动态规划比较好。</p><p>使用步骤：</p><ol><li>将复杂问题分解成具有相同解法的小问题</li><li>若小问题规模足够小，直接解决，否则递归解决各个小问题；</li><li>合并各个子问题的解。</li></ol><br><h2 id="动态规划" tabindex="-1">动态规划 <a class="header-anchor" href="#动态规划" aria-label="Permalink to &quot;动态规划&quot;">​</a></h2><p>将复杂问题分解成若干小问题，按顺序逐一求解。处理问题时将满足条件的解保存，前驱问题的解能为后续问题的解提供有用信息。重复上述步骤，直到求出所有可能的解。最后在局部解中找到最优解。</p><p>与分治法最大的区别是，动态规划下一个子问题的解是建立在上一个子问题的解的基础上，进一步求解得到的。</p><p>如果一个问题具有以下特征：</p><ol><li>求最优解；</li><li>前驱问题的解确定后不受后继问题的解的干扰；</li><li>子问题之间不相互独立，后继问题的解依赖前驱问题的解。</li></ol><p>使用步骤：</p><ol><li>划分阶段，将问题按照一定维度进行拆分，划分后的各个子问题必须是有序或可排序的；</li><li>确定状态，将各个前驱问题的解通过一定状态表示出来，并将其保存；</li><li>确定决策和状态转移方程，转移状态就是根据前驱问题的状态通过决策求出现阶段的解，如果确定了决策状态转移方程就可以很快写出。通常的做法是根据相邻状态之间的关系来确定决策方法和转移方程；</li><li>寻找边界条件，状态转移方程是一个递推式，需要一个递归的终止条件。</li></ol><blockquote><p>动态规划的核心思想就是穷举求最值</p><p>只有列出<strong>正确的「状态转移方程」</strong>，才能正确地穷举</p><p>需要判断算法问题是否<strong>具备「最优子结构」</strong></p><p>动态规划问题<strong>存在「重叠子问题」</strong>，如果暴力穷举的话效率会很低，所以需要你使用「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算</p><p>子问题、最优子结构、状态转移方程就是动态规划三要素</p><p><strong>递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间</strong>。</p><p>「状态转移方程」是解决问题的核心，直接代表着暴力解法。<strong>动态规划问题最困难的就是写出这个暴力解，即状态转移方程</strong></p><p>只要写出暴力解，优化方法无非是用备忘录或者 DP table</p></blockquote><br><h2 id="贪心" tabindex="-1">贪心 <a class="header-anchor" href="#贪心" aria-label="Permalink to &quot;贪心&quot;">​</a></h2><blockquote><p>...</p></blockquote><br><h2 id="回溯" tabindex="-1">回溯 <a class="header-anchor" href="#回溯" aria-label="Permalink to &quot;回溯&quot;">​</a></h2><blockquote><p>...</p></blockquote><br><h2 id="分支界限" tabindex="-1">分支界限 <a class="header-anchor" href="#分支界限" aria-label="Permalink to &quot;分支界限&quot;">​</a></h2><blockquote><p>...</p></blockquote><br><h2 id="kmp" tabindex="-1">KMP <a class="header-anchor" href="#kmp" aria-label="Permalink to &quot;KMP&quot;">​</a></h2><p><a href="https://www.zhihu.com/question/21923021/answer/281346746" target="_blank" rel="noreferrer">如何更好地理解和掌握 KMP 算法?</a></p>',30),i=[r];function p(s,n,h,c,d,_){return t(),o("div",null,i)}const q=a(l,[["render",p]]);export{u as __pageData,q as default};
