<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redis | Gnl&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/img/head-logo.jpeg">
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.b3c2438b.css" as="style"><link rel="preload" href="/assets/js/app.4235ef92.js" as="script"><link rel="preload" href="/assets/js/2.56b23ebb.js" as="script"><link rel="preload" href="/assets/js/8.278983a5.js" as="script"><link rel="prefetch" href="/assets/js/10.bd632ef2.js"><link rel="prefetch" href="/assets/js/11.97e98f56.js"><link rel="prefetch" href="/assets/js/12.6b813579.js"><link rel="prefetch" href="/assets/js/13.a92fbbe5.js"><link rel="prefetch" href="/assets/js/14.a6a78c23.js"><link rel="prefetch" href="/assets/js/15.21cf06a0.js"><link rel="prefetch" href="/assets/js/16.6e1cf1ef.js"><link rel="prefetch" href="/assets/js/17.8fc5265c.js"><link rel="prefetch" href="/assets/js/18.bfb6090d.js"><link rel="prefetch" href="/assets/js/19.61ada9bb.js"><link rel="prefetch" href="/assets/js/20.a2604dd9.js"><link rel="prefetch" href="/assets/js/21.3b5fe29c.js"><link rel="prefetch" href="/assets/js/22.0e3c1900.js"><link rel="prefetch" href="/assets/js/23.3160786c.js"><link rel="prefetch" href="/assets/js/24.a2e4bfcc.js"><link rel="prefetch" href="/assets/js/25.40511807.js"><link rel="prefetch" href="/assets/js/3.cf1d042b.js"><link rel="prefetch" href="/assets/js/4.9708d0a3.js"><link rel="prefetch" href="/assets/js/5.c185119b.js"><link rel="prefetch" href="/assets/js/6.c6dd3000.js"><link rel="prefetch" href="/assets/js/7.a201f36e.js"><link rel="prefetch" href="/assets/js/9.e78eec05.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b3c2438b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/head-logo.jpeg" alt="Gnl's Blog" class="logo"> <span class="site-name can-hide">Gnl's Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法" class="dropdown-title"><span class="title">算法</span> <span class="arrow down"></span></button> <button type="button" aria-label="算法" class="mobile-dropdown-title"><span class="title">算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/algorithm/Algorithm.html" class="nav-link">
  算法基础
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/JavaScript.html" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/frontend/TypeScript.html" class="nav-link">
  TypeScript
</a></li><li class="dropdown-item"><!----> <a href="/frontend/Vue.js.html" class="nav-link">
  Vue.js
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后端" class="dropdown-title"><span class="title">后端</span> <span class="arrow down"></span></button> <button type="button" aria-label="后端" class="mobile-dropdown-title"><span class="title">后端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/backend/设计模式.html" class="nav-link">
  设计模式
</a></li><li class="dropdown-item"><!----> <a href="/backend/Java.html" class="nav-link">
  Java
</a></li><li class="dropdown-item"><!----> <a href="/backend/Spring.html" class="nav-link">
  Spring
</a></li><li class="dropdown-item"><!----> <a href="/backend/SpringBoot.html" class="nav-link">
  SpringBoot
</a></li><li class="dropdown-item"><!----> <a href="/backend/SpringCloud.html" class="nav-link">
  SpringCloud
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据库" class="mobile-dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/database/MySQL.html" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/database/Redis.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Redis
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="中间件" class="dropdown-title"><span class="title">中间件</span> <span class="arrow down"></span></button> <button type="button" aria-label="中间件" class="mobile-dropdown-title"><span class="title">中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/middleware/RocketMQ.html" class="nav-link">
  RocketMQ
</a></li><li class="dropdown-item"><!----> <a href="/middleware/ElasticSearch.html" class="nav-link">
  ElasticSearch
</a></li><li class="dropdown-item"><!----> <a href="/middleware/Kafka.html" class="nav-link">
  Kafka
</a></li></ul></div></div><div class="nav-item"><a href="/About.html" class="nav-link">
  关于
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法" class="dropdown-title"><span class="title">算法</span> <span class="arrow down"></span></button> <button type="button" aria-label="算法" class="mobile-dropdown-title"><span class="title">算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/algorithm/Algorithm.html" class="nav-link">
  算法基础
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/JavaScript.html" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/frontend/TypeScript.html" class="nav-link">
  TypeScript
</a></li><li class="dropdown-item"><!----> <a href="/frontend/Vue.js.html" class="nav-link">
  Vue.js
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后端" class="dropdown-title"><span class="title">后端</span> <span class="arrow down"></span></button> <button type="button" aria-label="后端" class="mobile-dropdown-title"><span class="title">后端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/backend/设计模式.html" class="nav-link">
  设计模式
</a></li><li class="dropdown-item"><!----> <a href="/backend/Java.html" class="nav-link">
  Java
</a></li><li class="dropdown-item"><!----> <a href="/backend/Spring.html" class="nav-link">
  Spring
</a></li><li class="dropdown-item"><!----> <a href="/backend/SpringBoot.html" class="nav-link">
  SpringBoot
</a></li><li class="dropdown-item"><!----> <a href="/backend/SpringCloud.html" class="nav-link">
  SpringCloud
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><span class="title">数据库</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据库" class="mobile-dropdown-title"><span class="title">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/database/MySQL.html" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/database/Redis.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Redis
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="中间件" class="dropdown-title"><span class="title">中间件</span> <span class="arrow down"></span></button> <button type="button" aria-label="中间件" class="mobile-dropdown-title"><span class="title">中间件</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/middleware/RocketMQ.html" class="nav-link">
  RocketMQ
</a></li><li class="dropdown-item"><!----> <a href="/middleware/ElasticSearch.html" class="nav-link">
  ElasticSearch
</a></li><li class="dropdown-item"><!----> <a href="/middleware/Kafka.html" class="nav-link">
  Kafka
</a></li></ul></div></div><div class="nav-item"><a href="/About.html" class="nav-link">
  关于
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>数据库</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/database/MySQL.html" class="sidebar-link">MySQL</a></li><li><a href="/database/Redis.html" aria-current="page" class="active sidebar-link">Redis</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/database/Redis.html#什么是redis" class="sidebar-link">什么是Redis</a></li><li class="sidebar-sub-header"><a href="/database/Redis.html#常用命令" class="sidebar-link">常用命令</a></li><li class="sidebar-sub-header"><a href="/database/Redis.html#内部结构" class="sidebar-link">内部结构</a></li><li class="sidebar-sub-header"><a href="/database/Redis.html#数据类型" class="sidebar-link">数据类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/database/Redis.html#基本数据类型-5" class="sidebar-link">基本数据类型（5）</a></li><li class="sidebar-sub-header"><a href="/database/Redis.html#特殊数据类型-3" class="sidebar-link">特殊数据类型（3）</a></li></ul></li><li class="sidebar-sub-header"><a href="/database/Redis.html#事务" class="sidebar-link">事务</a></li><li class="sidebar-sub-header"><a href="/database/Redis.html#持久化" class="sidebar-link">持久化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/database/Redis.html#rdb" class="sidebar-link">RDB</a></li><li class="sidebar-sub-header"><a href="/database/Redis.html#aof" class="sidebar-link">AOF</a></li><li class="sidebar-sub-header"><a href="/database/Redis.html#混合持久化" class="sidebar-link">混合持久化</a></li></ul></li><li class="sidebar-sub-header"><a href="/database/Redis.html#高可用" class="sidebar-link">高可用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/database/Redis.html#主从复制" class="sidebar-link">主从复制</a></li><li class="sidebar-sub-header"><a href="/database/Redis.html#哨兵模式-sentinel" class="sidebar-link">哨兵模式（Sentinel）</a></li><li class="sidebar-sub-header"><a href="/database/Redis.html#redis集群" class="sidebar-link">Redis集群</a></li></ul></li><li class="sidebar-sub-header"><a href="/database/Redis.html#消息发布-订阅" class="sidebar-link">消息发布/订阅</a></li><li class="sidebar-sub-header"><a href="/database/Redis.html#缓存" class="sidebar-link">缓存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/database/Redis.html#缓存穿透" class="sidebar-link">缓存穿透</a></li><li class="sidebar-sub-header"><a href="/database/Redis.html#缓存击穿" class="sidebar-link">缓存击穿</a></li><li class="sidebar-sub-header"><a href="/database/Redis.html#缓存雪崩-缓存失效" class="sidebar-link">缓存雪崩/缓存失效</a></li></ul></li><li class="sidebar-sub-header"><a href="/database/Redis.html#淘汰策略" class="sidebar-link">淘汰策略</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/database/Redis.html#缓存淘汰策略" class="sidebar-link">缓存淘汰策略</a></li><li class="sidebar-sub-header"><a href="/database/Redis.html#内存淘汰机制-redis-内存满触发" class="sidebar-link">内存淘汰机制（Redis 内存满触发）</a></li></ul></li><li class="sidebar-sub-header"><a href="/database/Redis.html#渐进式-rehash" class="sidebar-link">渐进式 Rehash</a></li><li class="sidebar-sub-header"><a href="/database/Redis.html#分布式锁" class="sidebar-link">分布式锁</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/database/Redis.html#mysql和redis双写-读写不一致" class="sidebar-link">MySQL和Redis双写/读写不一致</a></li><li class="sidebar-sub-header"><a href="/database/Redis.html#分布式锁实现" class="sidebar-link">分布式锁实现</a></li></ul></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="redis"><a href="#redis" class="header-anchor">#</a> Redis</h1> <h2 id="什么是redis"><a href="#什么是redis" class="header-anchor">#</a> 什么是Redis</h2> <p><strong>Redis是单线程的吗？</strong></p> <p>不完全正确，Redis是一个Key-Value的非关系型数据库，我们所理解的Redis单线程主要是指网络IO和K-V的读写是由一个主线程来完成的。但Redis的其他功能，比如说持久化、异步删除、集群数据同步，其实是开启了额外的线程来完成的</p> <p><strong>优点/Redis单线程为什么还能这么快</strong></p> <p>1、Redis 完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度是 O(1)</p> <p>2、数据结构简单，对数据操作也简单</p> <p>Redis 的数据结构是有特殊设计的，比如 String 类型采用 sds 数据结构来存储。String的空间不够时，总是尝试去申请更多的内存；String空间多余的时候，不把多余的空间还给系统，而是会将多余的空间维护起来。通过这种方式来减少内存的申请，可以更快实现对数据的操作。有序集合 zset 采用的跳跃表，获取数据时可以通过不同的层次间跳跃来达到加速访问节点的效果</p> <p>3、Redis 的主体模式还是单线程的，避免了不必要的上下文切换和竞争条件，不存在多线程导致的 CPU 切换。不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗。官方也解释到：Redis 的性能不在 CPU，而在内存。</p> <p>4、使用多路复用 IO 模型，非阻塞 IO</p> <p>IO 多路复用就是多个 TCP 连接复用一个线程。如果采用多个请求起多个进程或者多个线程的模式，除了要考虑到进程或者线程的切换之外，还要用户去检查事件是否到达，效率低下。Redis 支持 select、poll、epoll 模式的多路复用，默认情况下，会选择系统支持的最好的模式。通过 IO 多路复用技术，用户不用去遍历 fd set 集合。通过内核通知告诉事件的到达，效率比较高</p> <p>5、渐进式 Rehash</p> <h2 id="常用命令"><a href="#常用命令" class="header-anchor">#</a> <strong>常用命令</strong></h2> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># 切换数据库0-15</span>
<span class="token keyword">select</span> dbIndex
<span class="token comment"># 遍历当前库所有键</span>
keys *
<span class="token comment"># 查询当前库总键数</span>
dbsize
<span class="token comment"># 存在返回1，不存在返回0</span>
exists key
<span class="token comment"># 删除键</span>
del key
<span class="token comment"># flushdb只清除当前数据库，flushall清除所有数据库</span>
flushdb
flushall

<span class="token comment"># （不建议再生产环境中使用）把指定的键从源数据库移动到目标数据库</span>
move key db

<span class="token comment"># 键数据类型</span>
<span class="token builtin class-name">type</span> key
<span class="token comment"># 键重命名，若newkey已存在，将会被覆盖</span>
<span class="token function">rename</span> key newkey
<span class="token comment"># 只有newkey不存在时才会被覆盖</span>
renamenx key newkey
<span class="token comment"># 随机返回一个键</span>
randomkey

<span class="token comment"># 当超过过期时间，会自动删除，key在seconds秒后过期</span>
expire key seconds
<span class="token comment"># 键在秒级时间戳timestamp后过期</span>
expireat key timestamp
<span class="token comment"># 当超过过期时间，会自动删除，key在milliseconds毫秒后过期</span>
pexpire key milliseconds
<span class="token comment"># key在豪秒级时间戳timestamp后过期</span>
pexpireat key milliseconds-timestamp
<span class="token comment"># 命令可以查看键hello的剩余过期时间，单位：秒（&gt;0剩余过期时间；-1没设置过期时间；-2键不存在）</span>
ttl
<span class="token comment"># 毫秒级ttl</span>
pttl

<span class="token comment"># 排序</span>
<span class="token function">sort</span> mylist
<span class="token comment"># 字母排序</span>
<span class="token function">sort</span> mylist alpha desc limit <span class="token number">0</span> <span class="token number">2</span>
<span class="token comment"># by命令</span>
<span class="token function">sort</span> list by it:* desc
<span class="token comment"># get参数</span>
<span class="token function">sort</span> list by it:* desc get it:*
<span class="token comment"># sort命令之store参数：表示把sort查询的结果集保存起来</span>
<span class="token function">sort</span> list by it:* desc get it:* store sorc:result
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br></div></div><h2 id="内部结构"><a href="#内部结构" class="header-anchor">#</a> 内部结构</h2> <blockquote><p>Redis 内部使用一个 redisObject 对象来表示所有的 key 和 value</p></blockquote> <p><strong>redisObject 最主要的信息</strong></p> <ul><li><p>type，表示一个 value 对象具体是何种数据类型</p></li> <li><p>encoding，是不同数据类型在 Redis 内部的存储方式</p> <p>type=string，表示 value 存储的是一个普通字符串， encoding 可以是 raw 或者 int</p></li></ul> <p><img src="/assets/img/image-20210528110958956.3d88708c.png" alt="image-20210528110958956"></p> <h2 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> 数据类型</h2> <h3 id="基本数据类型-5"><a href="#基本数据类型-5" class="header-anchor">#</a> 基本数据类型（5）</h3> <h4 id="string"><a href="#string" class="header-anchor">#</a> String</h4> <blockquote><p>String 是 Redis 最基本的类型，String 类型是二进制安全的，意思是 Redis 的 String 类型可以包含任何数据，比如 jpg 图片或者序列化的对象。String 类型的值最大能存储 512M</p></blockquote> <p><strong>操作</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token builtin class-name">set</span> key value
<span class="token comment"># 键必须不存在，才可以设置成功</span>
setnx key value
<span class="token comment"># 为键值设置秒级过期时间</span>
setex key value
<span class="token comment"># 从index开始替换value</span>
setrange key index value 

<span class="token comment"># 批量设置值</span>
mset k1 v1 k2 v2 k3 v3
mget k1 k2 k3

<span class="token comment"># key计数增</span>
incr key
<span class="token comment"># key计数增，每次增increment</span>
incr key by increment
<span class="token comment"># key计数减</span>
decr key
decr key by increment

<span class="token comment"># 追加值，向key中的value字符串尾部追加值</span>
append key value

<span class="token comment"># 字符串长度，每个汉字占用3个字字节</span>
strlen key

<span class="token comment"># 设置并返回原值</span>
getset key value

<span class="token comment"># 获取部分字符串，start和end分别为开始和结束的偏移量，偏移量从0开始</span>
getrange key start end 

<span class="token comment"># 设置指定位置的字符，offeset是字符串下标</span>
setrange key offeset value
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> key aaa
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get key
<span class="token string">&quot;aaa&quot;</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> setrange key <span class="token number">0</span> b
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get key
<span class="token string">&quot;baa&quot;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br></div></div><p><strong>String key设置约定</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># 中间不能用空格来隔开</span>
表名:主键名:主键值:字段名 字段值
user:id:1001:name aaa
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="list"><a href="#list" class="header-anchor">#</a> List</h4> <blockquote><p>List 列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边）</p></blockquote> <p><strong>数据结构</strong></p> <p>List 就是链表，可以用来当消息队列用</p> <p><strong>实现方式</strong></p> <p>Redis List 的是实现是一个双向链表，既可以支持反向查找和遍历，更方便操作，不过带来了额外的内存开销</p> <p><strong>操作</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment">#添加</span>
<span class="token comment"># 从右边插入元素</span>
rpush lists elements<span class="token punctuation">[</span>elements <span class="token builtin class-name">.</span> <span class="token builtin class-name">.</span> .<span class="token punctuation">]</span>
rpush lists a b c d
<span class="token comment"># 从左边插入元素</span>
lpush lists elements<span class="token punctuation">[</span>elements <span class="token builtin class-name">.</span> <span class="token builtin class-name">.</span> .<span class="token punctuation">]</span>
<span class="token comment"># 向某个元素前或者后插入元素</span>
linsert lists BEFORE<span class="token operator">|</span>AFTER element value

<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> linsert list before a z
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">5</span>
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> lrange list <span class="token number">0</span> -1
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;z&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;a&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;b&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;c&quot;</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">&quot;d&quot;</span>

<span class="token comment"># 遍历</span>
<span class="token comment"># 获取指定范围内的元素列表</span>
lrange key <span class="token number">0</span> -1
<span class="token comment"># 获取列表指定下标的元素</span>
lindex key <span class="token number">0</span>
<span class="token comment"># 获取列表长度</span>
llen key

<span class="token comment"># 删除</span>
<span class="token comment"># 从列表左侧弹出元素</span>
lpop key
<span class="token comment"># 从列表右侧弹出元素</span>
rpop key
<span class="token comment"># 删除count个指定元素value，若是指定元素个数小于count，则全部删除</span>
lrem key count value

<span class="token comment"># 修改</span>
<span class="token comment"># 修改指定索引下标的元素</span>
lset key index newValue
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><h4 id="hash"><a href="#hash" class="header-anchor">#</a> Hash</h4> <blockquote><p>Hash是一个键值（key-value）的集合。Redis 的 Hash 是一个 String 的 Key 和 Value 的映射表，Hash 适合存储对象</p></blockquote> <p><strong>操作</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># 设置值</span>
hset key field value
hsetnx key filed value
<span class="token comment"># 批量设置值</span>
Hmset key field value <span class="token punctuation">[</span>field value<span class="token punctuation">]</span>
<span class="token comment"># 判断field是否存在</span>
hexists key field

<span class="token comment"># 获取值</span>
hget key field
<span class="token comment"># 批量获取值</span>
Hmget key field <span class="token punctuation">[</span>field <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">]</span>
<span class="token comment"># 计算field的个数</span>
hlen key
<span class="token comment"># 计算value字符串的长度</span>
hstrlen key field
<span class="token comment"># 获取所有field</span>
hkeys key
<span class="token comment"># 获取所有value</span>
hvals key
<span class="token comment"># 获取所有的field、value</span>
hgetall key
<span class="token comment"># hincrby hincrbyfloat 作用域是field</span>
hincrby key field
hincrbyfloat key field

<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> hset user:1 name aaa age <span class="token number">18</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> hget user:1 name
<span class="token string">&quot;aaa&quot;</span>
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> hget user:1 age
<span class="token string">&quot;18&quot;</span>
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> hget user:1 password
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>

<span class="token comment"># 删除field，会删除一个或多个field，返回结果为成功删除fiel的个数</span>
hdel key field

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><h4 id="set"><a href="#set" class="header-anchor">#</a> Set</h4> <blockquote><p>Set 是 String 类型的无序集合。集合是通过 hashtable 实现的。Set 中的元素是没有顺序的，而且是没有重复的</p></blockquote> <p><strong>操作</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># 添加</span>
<span class="token comment"># 返回结果为添加成功的元素个数</span>
sadd key element <span class="token punctuation">[</span>element <span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 获取</span>
smembers key
<span class="token comment"># 获取set中元素个数</span>
scard key
<span class="token comment"># 判断元素是否存在set中，存在返回1，否则返回0 </span>
sismember key element
<span class="token comment"># 随机从集合返回指定个数元素，count可以省略，默认是1</span>
srandmember key <span class="token punctuation">[</span>count<span class="token punctuation">]</span>

<span class="token comment"># 删除</span>
<span class="token comment"># 返回结果为删除成功的元素个数</span>
srem key element <span class="token punctuation">[</span>element <span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token comment"># 从set中随机pop元素，count可以省略，默认1</span>
spop key <span class="token punctuation">[</span>count<span class="token punctuation">]</span>

<span class="token comment"># set集合间的操作</span>
<span class="token comment"># 交集</span>
sinter key <span class="token punctuation">[</span>key <span class="token builtin class-name">.</span> <span class="token builtin class-name">.</span> .<span class="token punctuation">]</span>
<span class="token comment"># 并集</span>
sunion key <span class="token punctuation">[</span>key <span class="token builtin class-name">.</span> <span class="token builtin class-name">.</span> .<span class="token punctuation">]</span>
<span class="token comment"># 差集</span>
<span class="token function">sdiff</span> key <span class="token punctuation">[</span>key <span class="token builtin class-name">.</span> <span class="token builtin class-name">.</span> .<span class="token punctuation">]</span>

<span class="token comment"># 将交集、并集、差集的结果保存，destination：保存到的目的地</span>
sinterstore destination key <span class="token punctuation">[</span> key <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">]</span>
sunionstore destination key <span class="token punctuation">[</span> key <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">]</span>
sdiffstore destination key <span class="token punctuation">[</span> key <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">]</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><h4 id="zset"><a href="#zset" class="header-anchor">#</a> Zset</h4> <blockquote><p>Zset 和 Set 一样是 String 类型元素的集合，且是插入有序的，即自动排序。和 Set 相比，Sorted Set关联了一个 Double 类型权重的参数 Score，使得集合中的元素能够按照 Score 进行有序排列，Redis 正是通过分数来为集合中的成员进行从小到大的排序</p></blockquote> <p><strong>实现方式</strong></p> <p>Redis Sorted Set 的内部使用 HashMap 和跳跃表（skipList）来保证数据的存储和有序，HashMap 里放的是成员到 Score 的映射。而跳跃表里存放的是所有的成员，排序依据是 HashMap 里存的 Score，使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单</p> <p><strong>操作</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># 添加</span>
<span class="token comment"># Add one or more members to a sorted set, or update its score if it already exists</span>
zadd key <span class="token punctuation">[</span>NX<span class="token operator">|</span>XX<span class="token punctuation">]</span> <span class="token punctuation">[</span>GT<span class="token operator">|</span>LT<span class="token punctuation">]</span> <span class="token punctuation">[</span>CH<span class="token punctuation">]</span> <span class="token punctuation">[</span>INCR<span class="token punctuation">]</span> score member <span class="token punctuation">[</span>score member <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
zadd key score member <span class="token punctuation">[</span>score member <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 增加成员的分数</span>
zincrby key increment member

<span class="token comment"># 返回指定排名范围的成员</span>
<span class="token comment"># 从低分到高分</span>
zrange key start end <span class="token punctuation">[</span>withscores<span class="token punctuation">]</span>
<span class="token comment"># 从高分到低分</span>
zrevrange key start end <span class="token punctuation">[</span>withscores<span class="token punctuation">]</span> 

<span class="token comment"># 返回指定分数范围的成员</span>
<span class="token comment"># 按照分数从低分到高分</span>
zrange key min max <span class="token punctuation">[</span>withscores<span class="token punctuation">]</span> <span class="token punctuation">[</span>limit offset count <span class="token punctuation">]</span>
<span class="token comment"># 按照分数从高分到低分</span>
zrevrange key max min <span class="token punctuation">[</span>withscores<span class="token punctuation">]</span> <span class="token punctuation">[</span>limit offset count <span class="token punctuation">]</span>
<span class="token comment"># 返回指定分数范围的成员个数</span>
zcount key min max

<span class="token comment"># 计算成员个数</span>
zcard key
<span class="token comment"># 计算某个成员分数</span>
zsore key member
<span class="token comment"># 从0开始计算成员的排名</span>
zrank key member

<span class="token comment"># 删除</span>
<span class="token comment"># 删除成员</span>
zrem key member <span class="token punctuation">[</span>member <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token comment"># 删除指定排名内的升序元素</span>
zremrangebyrank key start end
<span class="token comment"># 删除指定分数范围的成员</span>
zremrangebystore key min max

<span class="token comment"># zset集合操作</span>
<span class="token comment"># 交集</span>
zinter key <span class="token punctuation">[</span>key <span class="token builtin class-name">.</span> <span class="token builtin class-name">.</span> .<span class="token punctuation">]</span>
<span class="token comment"># 并集</span>
zunion key <span class="token punctuation">[</span>key <span class="token builtin class-name">.</span> <span class="token builtin class-name">.</span> .<span class="token punctuation">]</span>
<span class="token comment"># 差集</span>
zdiff key <span class="token punctuation">[</span>key <span class="token builtin class-name">.</span> <span class="token builtin class-name">.</span> .<span class="token punctuation">]</span>

<span class="token comment"># 将交集、并集、差集的结果保存，destination：保存到的目的地</span>
zinterstore destination key <span class="token punctuation">[</span> key <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">]</span>
zunionstore destination key <span class="token punctuation">[</span> key <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">]</span>
zdiffstore destination key <span class="token punctuation">[</span> key <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">]</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br></div></div><h5 id="跳跃表"><a href="#跳跃表" class="header-anchor">#</a> 跳跃表</h5> <blockquote><p>Redis 的 <strong>zset</strong> 是个复合结构, 是由一个 <strong>哈希表</strong> 和 <strong>skiplist</strong> 组成的。其中 hash 用来保存 value 和 score 对应关系，skiplist 用来给 score 排序</p></blockquote> <p><strong>SkipList 跳跃表</strong></p> <p>Zset 需要高效的插入和删除，数组插入删除的时间复杂度为O（n），所以底层不适合使用数组实现。需要使用链表，链表的插入删除的时间复杂度为O（1）。当插入新元素时需要根据 score 插入到链表合适的位置，保证链表的有序性， 高效的办法是通过<strong>二分查找</strong>去找到插入点</p> <blockquote><p>那么问题就来了，二分查找的对象必须是有序数组，只有数组支持快速定位，链表做不到该怎么办呢?</p></blockquote> <p>这就需要<strong>跳跃表</strong>了</p> <p>参考链接，后续再加上总结</p> <blockquote><p>关于排序问题，我们也很容易就想到 <strong>红黑树/ 平衡树</strong> 这样的树形结构，为什么 Redis 不使用这样一些结构呢？</p></blockquote> <ol><li><strong>性能考虑：</strong> 在高并发的情况下，树形结构需要执行一些类似于 rebalance 这样的可能涉及整棵树的操作，相对来说跳跃表的变化只涉及局部</li> <li><strong>实现考虑：</strong> 在复杂度与红黑树相同的情况下，跳跃表实现起来更简单，看起来也更加直观</li></ol> <h3 id="特殊数据类型-3"><a href="#特殊数据类型-3" class="header-anchor">#</a> 特殊数据类型（3）</h3> <h4 id="geospatial"><a href="#geospatial" class="header-anchor">#</a> Geospatial</h4> <blockquote><p>地理位置，记录某地点的经纬度，可用来求两地的距离、距离范围内的值等</p></blockquote> <p><strong>操作</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># 添加</span>
geoadd  key <span class="token punctuation">[</span>NX<span class="token operator">|</span>XX<span class="token punctuation">]</span> <span class="token punctuation">[</span>CH<span class="token punctuation">]</span> longitude latitude member <span class="token punctuation">[</span>longitude latitude member <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token comment"># 例子</span>
geoadd china:city <span class="token number">120.20000</span> <span class="token number">30.26667</span> hangzhou
geoadd china:city <span class="token number">120.20000</span> <span class="token number">30.26667</span> hangzhou <span class="token number">121.473720</span> <span class="token number">31.230350</span> shanghai

<span class="token comment"># 获取</span>
geopos key member <span class="token punctuation">[</span>member. <span class="token builtin class-name">.</span> .<span class="token punctuation">]</span>
geoadd china:city hangzhou shanghai

<span class="token comment"># 获取两地距离，默认距离单位m</span>
geodist china:key hangzhou shanghai
geodist china:key hangzhou shanghai km
<span class="token comment"># 以某个地理位置为中心，找出某半径内的包含的位置</span>
georadius key longitude latitude radius m<span class="token operator">|</span>km<span class="token operator">|</span>ft<span class="token operator">|</span>mi <span class="token punctuation">[</span>WITHCOORD<span class="token punctuation">]</span> <span class="token punctuation">[</span>WITHDIST<span class="token punctuation">]</span> <span class="token punctuation">[</span>WITHHASH<span class="token punctuation">]</span> <span class="token punctuation">[</span>COUNT count <span class="token punctuation">[</span>ANY<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>ASC<span class="token operator">|</span>DESC<span class="token punctuation">]</span> <span class="token punctuation">[</span>STORE key<span class="token punctuation">]</span> <span class="token punctuation">[</span>STOREDIST key<span class="token punctuation">]</span>
georadius key 经度 纬度 半径 半径单位m/km 包含直线距离 显示经纬度 count 显示的个数 升序/降序
<span class="token comment"># 根据给定的成员元素，找出指定距离内的其他元素</span>
georadiusbymember china:city hangzhou <span class="token number">200</span> km withcoord withdist

<span class="token comment"># 获取位置元素地理位置的哈希值</span>
geohash key member <span class="token punctuation">[</span>member. <span class="token builtin class-name">.</span> .<span class="token punctuation">]</span>


<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> geodist china:city shanghai hangzhou km
<span class="token string">&quot;162.2105&quot;</span>
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> georadius china:city <span class="token number">120.2</span> <span class="token number">30.2</span> <span class="token number">200</span> km
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;hangzhou&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;shanghai&quot;</span>
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> georadius china:city <span class="token number">120.2</span> <span class="token number">30.2</span> <span class="token number">200</span> km withdist
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;hangzhou&quot;</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;7.4155&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;shanghai&quot;</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;167.2338&quot;</span>
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> georadius china:city <span class="token number">120.2</span> <span class="token number">30.2</span> <span class="token number">200</span> km withdist withcoord
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;hangzhou&quot;</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;7.4155&quot;</span>
   <span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;120.20000249147415161&quot;</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;30.2666706589875858&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;shanghai&quot;</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;167.2338&quot;</span>
   <span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;121.47371917963027954&quot;</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;31.2303488312778228&quot;</span>
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> georadiusbymember china:city hangzhou <span class="token number">200</span> km withcoord withdist
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;hangzhou&quot;</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;0.0000&quot;</span>
   <span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;120.20000249147415161&quot;</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;30.2666706589875858&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;shanghai&quot;</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;162.2105&quot;</span>
   <span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;121.47371917963027954&quot;</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;31.2303488312778228&quot;</span>

<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> geohash china:city hangzhou
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;wtmkpjyuph0&quot;</span>


</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br></div></div><h4 id="hyperloglog"><a href="#hyperloglog" class="header-anchor">#</a> Hyperloglog</h4> <blockquote><p>基数，数据集中不重复的元素个数，可用于求集合（交并补）。用于网页的访问量（UV）、点赞量，一个用户多次访问，也只能算作一个人</p></blockquote> <p><strong>操作</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># 添加</span>
pfadd key element <span class="token punctuation">[</span>element <span class="token builtin class-name">.</span> <span class="token builtin class-name">.</span> .<span class="token punctuation">]</span>
<span class="token comment"># 获取key基数</span>
pfcount key
<span class="token comment"># 将多个hyperloglog合并为一个</span>
pfmerge destkey sourcekey <span class="token punctuation">[</span>sourcekey <span class="token builtin class-name">.</span> <span class="token builtin class-name">.</span> .<span class="token punctuation">]</span>

<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> pfadd hyper a b c d e f g
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> pfcount hyper
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">7</span>
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> pfadd hyper a a b c
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> pfcount hyper
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">7</span>
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> pfadd hyper2 a c h i
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> pfmerge hyper0 hyper hyper2
OK
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> pfcount hyper0
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">9</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h4 id="bitmap"><a href="#bitmap" class="header-anchor">#</a> BitMap</h4> <blockquote><p>位图场景，有两个状态，0和1。可用于签到统计、状态统计等</p></blockquote> <p><strong>操作</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># 设置值，一般设置0或1</span>
setbit key value
<span class="token comment"># 获取值</span>
getbit key offset
<span class="token comment"># 统计某个键其值为1的数量</span>
bitcount key <span class="token punctuation">[</span>start end<span class="token punctuation">]</span>

<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> setbit sign <span class="token number">1</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> setbit sign <span class="token number">2</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> setbit sign <span class="token number">3</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> setbit sign <span class="token number">4</span> <span class="token number">0</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> setbit sign <span class="token number">5</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> getbit sign <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:6379<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> bitcount sign
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p><strong>BitMap 统计日活</strong></p> <p>统计今日登录的用户数，建立一个bitmap，每一位标识一个用户ID（假设是1亿，空间使用量1亿/8/1024/1024=11MB，仅仅只要11MB就能统计1亿用户的日活，且速度相当快）</p> <p>每次用户登录时会执行一次<code>setbit key user_id 1</code>。将 bitmap 中对应位置的值置为1，时间复杂度是O(1)。执行<code>bitcount key</code> 统计 bitmap 结果有多少个1（即活跃用户数）</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># 每个用户登录即设置一次</span>
setbit activity_user_20210810 <span class="token number">111000</span> <span class="token number">1</span>
<span class="token comment"># 统计某日活跃用户数</span>
bitcount activity_user_20210810

<span class="token comment"># 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上</span>
<span class="token comment"># operation 可以是 AND 逻辑并、 OR 逻辑或、 NOT 逻辑非、 XOR 逻辑异或 这四种操作中的任意一种</span>
<span class="token comment"># 除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入</span>
<span class="token comment"># BITOP 的复杂度为 O(N) ，当处理大型矩阵(matrix)或者进行大数据量的统计时，最好将任务指派到附属节点(slave)进行，避免阻塞主节点</span>
<span class="token comment">### 返回值：保存到 destkey 的字符串的长度，和输入 key 中最长的字符串长度相等</span>
bitop operation destkey key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 将一周内连续登录用户保存到res中</span>
bitop and res activity_0809 activity_0810 activity_0811 activity_0812 activity_0813 activity_0814 activity_0815
<span class="token comment"># 统计一周内连续登录用户</span>
bitcount res
<span class="token comment"># 判断某个用户是否在七天内连续登录，返回1，即七天内连续登录</span>
getbit res 用户id

<span class="token comment"># 统计周活</span>
bitop or res activity_0809 activity_0810 activity_0811 activity_0812 activity_0813 activity_0814 activity_0815
<span class="token comment"># 获取周活</span>
bitcount res
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h2 id="事务"><a href="#事务" class="header-anchor">#</a> 事务</h2> <blockquote><p>Redis事务的本质是一组命令的集合，可以一次执行多个命令。一个事务中所有的命令都会被序列化，一次性按顺序地，串行化执行，不会被其他命令插入</p></blockquote> <p><strong>锁</strong></p> <ul><li><strong>乐观锁</strong>，认为无论执行什么操作都不会出问题，无论执行什么操作都不会加锁
<ul><li>用version给数据做标识，更新数据时判断version，查看在此期间是否有人修改过这个数据</li> <li>提交版本必须大于记录当前版本才能执行更新</li></ul></li> <li><strong>悲观锁</strong>，认为无论执行什么操作都会出问题，无论执行什么操作都会加锁</li></ul> <p><strong>特点</strong></p> <ul><li>一个队列中，一次性、顺序性、排他性的执行一系列命令</li> <li>==Redis单条命令保证原子性，但是Redis事务不保证原子性，没有回滚==</li> <li>==Redis事务中没有隔离级别的概念==</li> <li>==所有命令在事务中并没有被直接执行，只有发起执行指令的时候才会执行==</li> <li>执行流程
<ol><li>开启事务，<code>multi</code></li> <li>输入一组命令，命令入队</li> <li>执行事务，<code>exec</code>，执行之后本次事务结束，若还要使用事务则需要再次开启</li> <li>取消事务，<code>discard</code></li> <li>监视key值，<code>watch key [key...]</code>，类似于乐观锁，如果在事务执行时，若是这个或这些key值被其他命令所改动，那么事务将会被打断。一旦执行了<code>exec</code>命令之后，之前加的监控锁都会被取消</li></ol></li> <li>事务不能正常开启的情况
<ol><li>编译异常，输入的命令编译异常，事务中所有的命令都不会成功执行</li> <li>运行异常，输入的命令在执行期间出现异常，除了出错的命令，其它命令均能正常执行</li></ol></li></ul> <p><strong>操作</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># 标记一个事务块的开始</span>
multi
<span class="token comment"># 执行事务块内的命令</span>
<span class="token builtin class-name">exec</span>

<span class="token comment"># 监视一个或者多个key，如果事务执行之前，这个kye被其它命令所动，则事务被打断</span>
<span class="token function">watch</span> key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token comment"># 取消watch命令对所有key的监视</span>
unwatch

<span class="token comment"># 取消执行事务块内的所有命令</span>
discard
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="持久化"><a href="#持久化" class="header-anchor">#</a> 持久化</h2> <p>Redis 最大的特点就是基于内存的，既然是基于内存，那么当 Redis 服务挂掉或者服务器宕机，数据则会丢失，所以 Redis 不可避免的得对数据持久化做一些处理</p> <h3 id="rdb"><a href="#rdb" class="header-anchor">#</a> RDB</h3> <blockquote><p>在指定时间间隔内，将内存中的数据保存到磁盘上的一个 dump 文件，定时保存。恢复的时候是将快照文件直接读到内存中，实现快速恢复</p></blockquote> <p><strong>RDB快照</strong></p> <p>Redis 提供了两个命令来生成 RDB 快照文件，分别是 <code>save</code> 和 <code>bgsave</code>。<code>save</code> 命令在主线程中执行，会导致阻塞。而 <code>bgsave</code> 命令则会创建一个子进程，用于写入 RDB 文件的操作，避免了对主线程的阻塞，这也是 Redis RDB 的默认配置</p> <p><strong>自动触发</strong></p> <div class="language-conf line-numbers-mode"><pre class="language-text"><code># save 单位时间(s) 修改次数
save 3600 1 # 3600s内修改超过1次，就将数据持久化到储存
save 300 100
save 60 10000
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>手动触发</strong></p> <ol><li>执行完命令之后，==手动执行 save 指令==</li> <li>==执行 flushdb 指令==，执行 flushdb 指令之后，会生成一个空的<code>dump.rdb</code>文件将之前的 RDB 文件覆盖</li></ol> <p><strong>禁用快照</strong></p> <ol><li>配置文件中开启 <code>save &quot;&quot;</code></li> <li>命令行执行<code>config set save &quot;&quot;</code></li></ol> <p><strong>异常 dump 文件修复</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># redis-check-dump在redis-server同级目录下</span>
redis-check-dump --fix dump.rdb
<span class="token comment"># 之后重启Redis生效</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>细节</strong></p> <ul><li>Redis 会单独创建（fork）一个子进程来进行持久化，会先将数据写到一个临时文件中，等持久化过程都结束了，再用这个临时文件替换上次持久化的文件。整个持久化过程主进程是不进行任何 IO 操作的，这就确保了极高的性能</li> <li>==Fork 的作用是复制一个与当前进行一样的子进程==，子进程的所有数据（变量，环境变量，程序计数器等）数值都与原来的进程一致，是一个全新的进程</li> <li>RDB 保存的是<code>dump.rdb</code>文件，备份的<code>dump.rdb</code>文件最好是与运行 Redis 的服务器==不同==的另一台服务器</li> <li>==如果要进行大规模的数据恢复，且对于数据恢复的完整性要求不是非常敏感，那么RDB方式要比AOF方式更加的高效==</li></ul> <p><strong>优点</strong></p> <ol><li><code>.rdb</code>是一个非常紧凑的文件</li> <li>RDB 在保存<code>.rdb</code>文件时，父进程唯一需要做的就是 fork 出一份子进程，接下来的工作全部由子进程来做，父进程不需要再做其他的 IO 操作，只需要专注于自己的工作。所以 RDB 持久化方式可以最大化 Redis 的性能</li> <li>与 AOF 相比，在恢复大的数据集的时候，RDB 方式会更快</li></ol> <p><strong>缺点</strong></p> <ol><li>数据丢失风险大，在一定间隔时间内做一次备份，如果 Redis 意外宕机，就会丢失最后一次快照后的所有修改</li> <li>Fork 的时候，内存中的数据被克隆了一份，大致两倍的膨胀性需要考虑。并且在数据集比较大的时候，Fork 过程是非常耗时的</li></ol> <p><strong>Redis 是怎么解决在 bgsave 做快照的时候允许数据修改？</strong></p> <p>这里主要是利用 <code>bgsave</code>的子线程实现的，具体操作如下：</p> <ul><li>如果主线程执行读操作，则主线程和 <code>bgsave</code> 子进程互相不影响；</li> <li>如果主线程执行写操作，则被修改的数据会复制一份副本，然后 <code>bgsave</code>子进程会把该副本数据写入 RDB 文件，在这个过程中，主线程仍然可以直接修改原来的数据。</li></ul> <h3 id="aof"><a href="#aof" class="header-anchor">#</a> AOF</h3> <blockquote><p>以日志的形式来记录每个写操作，将 Redis 执行过的<strong>所有写指令</strong>记录下来（读指令不记录），只许追加文件而不改写文件。Redis 启动时会读取 AOF 日志文件，重新构建数据。Redis 重启的话就根据日志文件的内容将指令从前到后执行执行一次，以完成数据的恢复工作</p></blockquote> <p><strong>写后日志</strong></p> <p>AOF 采用的是 “写后日志” 的方式，==主要是由于 Redis 在写入日志之前，不对命令进行语法检查，所以只记录执行成功的命令，避免出现记录错误命令的情况，而且在命令执行后再写日志不会阻塞当前的写操作==。后写日志主要有两个风险可能会发生：</p> <ul><li>数据可能会丢失：如果 Redis 刚执行完命令，此时发生故障宕机，会导致这条命令存在丢失的风险。</li> <li>可能阻塞其他操作：AOF 日志其实也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行</li></ul> <p><strong>AOF 快照</strong></p> <ul><li><p>启用 AOF</p> <div class="language-conf line-numbers-mode"><pre class="language-text"><code># 配置文件修改
appendonly yes
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>appendfsync，AOF 的命令同步策略</p> <ol><li>always，同步计划，每次发生数据变更会被立即记录到 AOF 文件，性能较差但是数据完整性较好</li> <li>everysec，出厂默认，异步操作，每秒记录，如果一秒内宕机，会出现数据丢失</li> <li>no</li></ol></li> <li><p>aof 文件异常修复</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># redis-check-aof在redis-server同级目录下</span>
redis-check-aof --fix appendonly.aof
<span class="token comment"># 之后重启Redis生效</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li></ul> <p><strong>AOF 的重写（rewrite）机制</strong></p> <ul><li>AOF 采用文件追加的方式，文件会越来越大，为了避免出现这种情况，AOF 新增了重写机制。</li> <li>当 AOF 文件的大小超过所设定的阈值时，Redis 就会启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集。可以使用<code>bgrewriteaof</code></li></ul> <p><strong>重写过程</strong></p> <p>AOF 文件持续增长而过大时，会 fork 出一条新进程来将文件重写（先写入临时文件再 rename ）遍历新进程的内存中的数据，每条记录都有一条 Set 语句。重写 AOF 文件的操作并没有读取到旧的 AOF 文件，而是将整个内存中的数据库内容用命令的方式重写一个新的 AOF 文件，这点和 RDB 快照有点类似</p> <ul><li><p>触发机制</p> <p>Redis 会记录上次重写时的 aof 文件的大小，默认配置是当 aof 文件大小是上次重写后大小的一倍，且文件大于 64MB 时触发。若是重启 Redis 后第一次触发重写机制，则重写时对照的 aof 文件的大小是 Redis 启动时使用的 aof 文件的大小</p></li></ul> <p><strong>细节</strong></p> <ul><li>aof 文件是一个只进行日志追加的文件</li> <li>==若是目录下同时存在<code>dump.rdb</code>和<code>appendonly.aof</code>，优先加载aof文件进行数据恢复。因为在通常情况下，aof 文件保存的数据要比rdb文件保存的数据更完整==</li> <li>==aof 文件会记录<code>flusdb</code>和<code>flushall</code>指令，若在操作的最后执行了<code>flushdb</code>，在下次启动时从aof文件恢复的指令中末尾就是<code>flushdb</code>，因此数据会被再次清空==</li></ul> <p><strong>优点</strong></p> <ol><li>aof 文件有序地保存了对数据库执行的所有写入操作，这些写入操作以aof格式的文件进行保存，aof文件内容易于读懂，对文件进行分析也很轻松</li> <li>同步策略配置灵活</li> <li>Redis 可以在 AOF 文件过大时，在后台自动的对 AOF 文件进行重写</li></ol> <p><strong>缺点</strong>：对相同数据集的数据而言，AOF 文件要远大于 RDB 文件，恢复速度要慢于 RDB 文件</p> <h3 id="混合持久化"><a href="#混合持久化" class="header-anchor">#</a> 混合持久化</h3> <blockquote><p>重启 Redis 时，很少使用 RDB来恢复数据，因为会丢失大量数据。通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 RDB来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。  Redis 为了解决这个问题，带来了一个新的持久化方式——混合持久化</p></blockquote> <p><strong>配置</strong></p> <div class="language-conf line-numbers-mode"><pre class="language-text"><code>aof-use-rdb-preamble yes
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>细节</strong></p> <p>如果开启了混合持久化，AOF 在重写时，==不再是单纯将内存数据转换为 RESP 命令写入 AOF 文件， 而是将重写这一刻之前的内存做 RDB 快照处理==，并且将 RDB 快照内容和增量的 AOF 修改内存数据的命令存在一起，都写入新的 AOF 文件， 新的文件一开始不叫<code>appendonly.aof</code>，等到重写完新的 AOF 文件才会进行改名，覆盖原有的 AOF 文件，完成新旧两个 AOF 文件的替换</p> <p>于是在 Redis 重启的时候，可以<strong>先加载 RDB 的内容，然后再重放增量 AOF 日志</strong>，就可以完全替代之前的 AOF 全量文件重放， 因此重启效率大幅得到提升。</p> <h2 id="高可用"><a href="#高可用" class="header-anchor">#</a> 高可用</h2> <h3 id="主从复制"><a href="#主从复制" class="header-anchor">#</a> 主从复制</h3> <blockquote><p>主从复制，主机数据更新后，根据配置和策略，自动同步到备份机的 Master/Slave 机制，Master 以写为主，Slave 以读为主</p></blockquote> <p><strong>作用</strong></p> <ol><li>读写分离</li> <li>容灾恢复</li></ol> <p><strong>一主多从配置</strong></p> <p>A、仅需要配置从库，不配置主库</p> <p>B、修改配置文件细节</p> <ol><li><p>拷贝多个<code>redis.conf</code>文件</p></li> <li><p>开启<code>deamonlize yes</code></p></li> <li><p>指定端口</p> <ol><li>同一台机上多个Redis服务改不同端口</li> <li>不同机子上Redis服务无需修改端口</li> <li>Pid文件名</li></ol> <div class="language-conf line-numbers-mode"><pre class="language-text"><code># redis.conf
pidfile /var/run/redis端口号.pid
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ol start="4"><li><p>Log文件名</p> <div class="language-conf line-numbers-mode"><pre class="language-text"><code># redis.conf
logfile &quot;端口号.log&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p><code>dump.rdb</code>名</p> <div class="language-conf line-numbers-mode"><pre class="language-text"><code>dbfilename dump端口号.rdb
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ol></li></ol> <p>C、从库配置，指定master</p> <ol><li><p>命令行指定，每次与master断开之后，都需要重新连接</p> <div class="language-conf line-numbers-mode"><pre class="language-text"><code># redis客户端命令行
slaveOf 主机ip 主机port
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>配置文件指定，在<code>redis.conf</code>中指定master</p></li></ol> <p>D、查看主从复制信息</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># redis客户端命令行</span>
info replication
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>去中心化配置</strong></p> <ul><li><p>上一个Slave是下一个Slave的Master，接力配置。Slave同样可以接受其他Slave的连接和同步请求，处于中间的Slave作为链条中下一个Slave的Master，可以有效减轻Master的写压力</p></li> <li><p>==需要注意的是，中途变更两种不同的master-slave配置会清除之前的数据，重新建立拷贝最新的数据==</p></li> <li><p>步骤同一主多从，仅在<code>slaveOf</code>命令处有改动</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>slaveOf 新主库ip 新主库port
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul> <p><strong>主从工作原理</strong></p> <p>1、为 Master 配置了一个 Slave 之后，不管这个 Slave 是否是第一次连接上 Master，它都会发送一个**<code>SYNC</code>命令(Redis 2.8 版本之前的命令)** Master 请求复制数据。(<strong>从2.8版本开始，Redis 改用可以支持部分数据复制的命令<code>PSYNC</code>去 Master 同步数据</strong>)</p> <p>2、Master 收到<code>SYNC</code>命令后，会在后台进行数据持久化通过<code>bgsave</code>生成最新的 RDB 快照文件，持久化期间，Master 会继续接收客户端的请求，它会把这些可能修改数据集的请求缓存在内存中。当持久化进行完毕以后，Master 会把这份 RDB 文件数据集发送给 Slave，Slave 会把接收到的数据进行持久化生成 RDB，然后再加载到内存中。最后，Master 再将之前缓存在内存中的命令发送给 Slave</p> <p>3、当 Master 与 Slave 之间的连接由于某些原因而断开时，Slave 能够自动重连 Master，如果 Master 收到了多个Slave 并发连接请求，它只会进行一次持久化，而不是一个连接一次，然后再把这一份持久化的数据发送给多个并发连接的 Slave</p> <p>4、当 Master 和 Slave 断开重连后，一般都会对整份数据进行复制。从 Redis 2.8 版本开始，Master 和 Slave 断开重连后支持<strong>部分复制</strong></p> <p><strong>数据的全量/增量复制</strong></p> <p>全量复制：Master 会在其内存中创建一个<strong>复制数据用的缓存队列</strong>，缓存最近一段时间的数据，Master 和它所有的Slave 都维护了复制的数据下标 offset 和 master 的进程 id。当网络连接断开后，slave 会请求 master 继续进行未完成的复制，从所记录的数据下标开始。如果 master 进程 id 变化了，或者从节点数据下标 offset 太旧，已经不在master 的缓存队列里了，那么将会进行一次全量数据的复制</p> <p>增量复制：Master继续将新的所有收集到的修改命令一次传给Slave，完成同步。但是只要是重新连接Master，将会自动执行一次完全的同步（全量复制）</p> <h3 id="哨兵模式-sentinel"><a href="#哨兵模式-sentinel" class="header-anchor">#</a> 哨兵模式（Sentinel）</h3> <blockquote><p>Sentinel 哨兵是特殊的 Redis 服务，<strong>不提供读写服务</strong>，主要<strong>用来监控 Redis 实例节点</strong>。能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p></blockquote> <p>哨兵架构下客户端第一次从哨兵找出 Redis 的主节点，后续就直接访问 Redis 的主节点，不会每次都通过 Sentinel 代理访问 Redis 的主节点，当 Redis 的主节点发生变化，哨兵会第一时间感知到，并且将新的 Redis 主节点通知给客户端(这里客户端一般都实现了订阅功能，订阅 Sentinel 发布的节点变动消息)</p> <p>在 Redis 3.0 以前的版本要实现集群一般是借助哨兵 Sentinel 工具来监控 master 节点的状态。==如果 master 节点异常，则会做主从切换，将某一台 slave 作为 master==。哨兵的配置略微复杂，并且性能和高可用性等各方面表现一般，特别是在主从切换的瞬间存在访问瞬断的情况。而且哨兵模式只有一个主节点对外提供服务，没法支持很高的并发，且单个主节点内存也不宜设置得过大，否则会导致持久化文件过大，影响数据恢复或主从同步的效率</p> <p><strong>配置</strong></p> <ol><li><p>配置一主多从</p></li> <li><p>自定义的Redis配置文件目录新建<code>sentinel.conf</code>文件</p></li> <li><p>配置哨兵，一组sentinel能监控多个Master</p> <div class="language-conf line-numbers-mode"><pre class="language-text"><code># sentinel.conf 最后的数字1表示，主机挂掉后Slave投票，看谁得票多让谁接替成为主机
sentinel minitor 被检控的主机名 主机ip 主机port 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>启动哨兵</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># redis目录命令行</span>
redis-sentinel /opt/redis/conf/sentinel.conf
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>注意，==若是原 Master 宕机，就会从剩下的 Slave 中选出新的 Master。原 Master 重新启动之后不再是 Master，而是成为新 Master 的 Slave==</p></li></ol> <p><strong>哨兵Leader选举流程</strong></p> <p>1、当一个 Sentinel 的 master 服务被某 sentinel 视为客观下线状态后，该 sentinel 会与其他 sentinel 协商选出 sentinel 的 leader 进行故障转移工作。</p> <p>2、每个发现 master 服务器进入客观下线的 sentinel 都可以要求其他 sentinel 选自己为 sentinel 的 leader，选举是先到先得。同时每个 sentinel 每次选举都会自增配置纪元(选举周期)，每个纪元中只会选择一个 sentinel 的 leader。</p> <p>3、如果所有超过一半的 sentinel 选举某 sentinel 作为 leader。之后该 sentinel 进行故障转移操作，从存活的 slave 中选举出新的 master，这个选举过程跟集群的 master 选举很类似</p> <p>哨兵集群可以只有一个哨兵节点，Redis 的主从也能正常运行以及选举 Master，如果 Master 挂了，那唯一的那个哨兵节点就是哨兵 leader 了，可以正常选举新 master</p> <p>不过为了高可用一般都推荐至少部署三个哨兵节点。推荐奇数个哨兵节点原理跟集群奇数个master节点类似</p> <h3 id="redis集群"><a href="#redis集群" class="header-anchor">#</a> Redis集群</h3> <blockquote><p>Redis Cluster 是一种<strong>分布式去中心化的运行模式</strong>，是在 Redis 3.0 版本中推出的 Redis 集群方案，它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能，它具有复制、高可用和分片特性</p></blockquote> <p>使用哨兵模式在数据上有副本数据做保证，在可用性上又有哨兵监控，一旦 master 宕机会选举 salve 节点为 master 节点，这种已经满足了我们的生产环境需要，<strong>那为什么还需要使用集群模式呢？</strong></p> <p>哨兵模式归根到底节点还是主从模式，在主从模式下我们可以通过增加 slave 节点来扩展读并发能力，但是没办法扩展写能力和存储能力，存储能力只能是 master 节点能够承载的上限。所以==为了扩展写能力和存储能力==，我们就需要引入集群模式</p> <p>Redis 集群不需要 sentinel 哨兵也能完成节点移除和故障转移的功能。需要将每个节点设置成集群模式，这种集群模式没有中心节点，可水平扩展，据官方文档称可以线性扩展到上万个节点(官方推荐不超过 1000 个节点)。redis 集群的性能和高可用性均优于之前版本的哨兵模式，且集群配置非常简单</p> <p><strong>Redis Cluster 在存储的时候如何确定选择哪个节点呢？</strong></p> <p>Redis Cluster采用的是<strong>类一致性哈希算法</strong>实现节点选择的。Redis Cluster将所有数据分成 16384 个<strong>Slot</strong>（槽位），哈希槽类似于数据分区。每个节点负责其中一部分槽位，槽位的信息存储于每个节点中。</p> <p>当 Redis Cluster 的客户端来连接集群时，它也会得到一份集群的槽位配置信息并将其缓存在客户端本地。这样当客户端要查找某个 key 时，可以直接定位到目标节点。同时因为槽位的信息可能会存在客户端与服务器不一致的情况，还需要纠正机制来实现槽位信息的校验调整</p> <p><strong>槽位定位算法</strong></p> <p>每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步。</p> <ul><li>根据键值对的 key，按照 CRC16 算法计算一个 16 bit 的值。</li> <li>再用 16bit 值对 16384 取模，得到 <code>0~16383</code> 范围内的模数，每个模数代表一个相应编号的哈希槽，<code>HASH_SLOT = CRC16(key) mod 16384</code></li></ul> <p><strong>跳转重定位</strong></p> <p>当客户端向一个错误的节点发出了指令，该节点会发现指令的 key 所在的槽位并不归自己管理，这时它会向客户端发送一个特殊的跳转指令携带目标操作的节点地址，告诉客户端去连这个节点去获取数据。客户端收到指令后除了跳转到正确的节点上去操作，还会同步更新纠正本地的槽位映射表缓存，后续所有 key 将使用新的槽位映射表。</p> <p><strong>Redis 集群节点间的通信机制</strong></p> <p>Redis Cluster节点间采取<strong>gossip协议</strong>进行通信，维护集群的元数据有两种方式：==集中式和gossip==</p> <p>1、<strong>集中式</strong>： 优点在于元数据的更新和读取，时效性非常好，一旦元数据出现变更立即就会更新到集中式的存储中，其他节点读取的时候立即就可以立即感知到；不足在于所有的元数据的更新压力全部集中在一个地方，可能导致元数据的存储压力</p> <p>2、<strong>gossip</strong>：gossip协议包含多种消息，包括ping，pong，meet，fail等等</p> <p>​		<strong>ping</strong>：每个节点都会频繁给其他节点发送ping，其中包含自己的状态还有自己维护的集群元数据，互相通过ping交换元数据；</p> <p>​		<strong>pong</strong>: 返回ping和meet，包含自己的状态和其他信息，也可以用于信息广播和更新；</p> <p>​		<strong>fail</strong>: 某个节点判断另一个节点fail之后，就发送fail给其他节点，通知其他节点，指定的节点宕机了；</p> <p>​		<strong>meet</strong>：某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始与其他节点进行通信，不需要发送形成网络的所需的所有CLUSTER MEET命令。发送CLUSTER MEET消息以便每个节点能够达到其他每个节点只需通过一条已知的节点链就够了。由于在心跳包中会交换gossip信息，将会创建节点间缺失的链接；</p> <blockquote><p>gossip协议的优点在于元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新，<strong>有一定的延时，降低了压力</strong>；缺点在于元数据更新有延时可能导致集群的一些操作会有一些滞后。</p></blockquote> <p><strong>Redis 集群选举原理分析</strong></p> <p>当 slave 发现自己的 master 变为 FAIL 状态时，便尝试进行 Failover，以期成为新的 master。由于挂掉的 master 可能会有多个 slave，从而存在多个 slave 竞争成为 master 节点的过程， 其过程如下：</p> <p>1、slave 发现自己的 master 变为 FAIL</p> <p>2、将自己记录的集群<code>currentEpoch</code>加1，并广播<code>FAILOVER_AUTH_REQUEST</code>信息</p> <p>3、其他节点收到该信息，只有 master 响应，判断请求者的合法性，并发送 FAILOVER_AUTH_ACK，对每一个 epoch 只发送一次 ack</p> <p>4、尝试 failover 的 slave 收集 master 返回的 FAILOVER_AUTH_ACK</p> <p>5、slave 收到超过半数 master 的 ack 后变成新 Master (这里解释了集群为什么至少需要三个主节点，如果只有两个，当其中一个挂了，只剩一个主节点是不能选举成功的)</p> <p>6、slave 广播 Pong 消息通知其他集群节点</p> <blockquote><p>从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟，一定的延迟确保我们等待FAIL 状态在集群中传播，slave 如果立即尝试选举，其它 masters 或许尚未意识到 FAIL 状态，可能会拒绝投票</p></blockquote> <p><strong>Redis集群为什么至少需要三个master节点，并且推荐节点数为奇数？</strong></p> <p>因为新master的选举需要大于半数的集群master节点同意才能选举成功，如果只有两个master节点，当其中一个挂了， 是达不到选举新master的条件的。</p> <p>奇数个master节点可以在满足选举该条件的基础上节省一个节点，比如三个master节点和四个master节点的集群相比， 大家如果都挂了一个master节点都能选举新master节点，如果都挂了两个master节点都没法选举新master节点了， 所以奇数的master节点更多的是从节省机器资源角度出发说的。</p> <h2 id="消息发布-订阅"><a href="#消息发布-订阅" class="header-anchor">#</a> 消息发布/订阅</h2> <blockquote><p>进程间的一种消息通信模式，发送者（pub）发送消息，订阅者（sub）接收消息</p></blockquote> <p>稍作了解即可，生产中消息发布订阅交给MQ来处理</p> <h2 id="缓存"><a href="#缓存" class="header-anchor">#</a> 缓存</h2> <h3 id="缓存穿透"><a href="#缓存穿透" class="header-anchor">#</a> 缓存穿透</h3> <blockquote><p>缓存穿透，指的是key值在==缓存和数据库中都不存在==。每次针对key的请求从缓存中获取不到，请求都会到数据库，从而可能压垮数据库。如发起请求查找ID不存在的数据，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击，可能会压垮数据库</p></blockquote> <p><strong>解决方案</strong></p> <ol><li>API接口层增加校验，如用户鉴权校验，对Id做基础校验，Id小于0直接拦截</li> <li><strong>缓存空对象</strong>，从缓存取不到的数据，在数据库中也没有取到，这时可以将<code>key-value</code>对写为<code>key-null</code>，缓存有效时间可以设置得短一点，如30s（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个Id暴力攻击</li> <li><strong>布隆过滤器</strong>，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力</li></ol> <h3 id="缓存击穿"><a href="#缓存击穿" class="header-anchor">#</a> 缓存击穿</h3> <blockquote><p>缓存击穿，指的是在==缓存过期后，有大量的请求并发的请求过期的键==，这时因为缓存已经过期，所有的请求都发送到数据库中。</p></blockquote> <p><strong>解决方案</strong></p> <ol><li><p>设置热点数据永不过期</p></li> <li><p>加<strong>互斥锁</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> res <span class="token operator">=</span> <span class="token function">getDataFromCache</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// tryLock，获取成功，去数据库取数据</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            res <span class="token operator">=</span> <span class="token function">getDataFromCache</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">setDataToCache</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 释放锁资源</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 等待一段时间后再重新获取数据</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">getData</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div></li></ol> <h3 id="缓存雪崩-缓存失效"><a href="#缓存雪崩-缓存失效" class="header-anchor">#</a> 缓存雪崩/缓存失效</h3> <blockquote><p>缓存雪崩，是指==缓存中有数据大批量过期，而对过期缓存的查询量又巨大，此时查询都到数据库，引起数据库压力过大==。与缓存击穿不同的是，缓存击穿是并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据在缓存中都查不到从而查数据库</p></blockquote> <p><strong>解决方案</strong></p> <ol><li><p>缓存数据的<strong>过期时间设置随机</strong>，防止同一时间大量数据过期现象发生</p></li> <li><p>通过加锁或者队列来控制读数据库写缓存的线程数量，比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p></li> <li><p>如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中</p></li> <li><p>设置热点数据永不过期</p></li> <li><p>设置<strong>缓存标记</strong></p> <p>缓存标记，记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新缓存。将缓存数据的过期时间设置为缓存标记过期时间的二倍。当标记缓存key过期后，实际缓存还能把旧数据返回给调用端，直到另外的线程在后台更新完成，才会返回新缓存</p></li></ol> <h2 id="淘汰策略"><a href="#淘汰策略" class="header-anchor">#</a> 淘汰策略</h2> <blockquote><p>因为 Redis 是基于内存的，内存的空间是非常宝贵的，所以数据不可能无上限的存储，必定会存在一个淘汰策略定期删除一些 key。</p></blockquote> <h3 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="header-anchor">#</a> 缓存淘汰策略</h3> <blockquote><p>通过统计访问频率，将访问频率最少，即最不经常使用的 KV 淘汰</p></blockquote> <p>那 Redis 的缓存淘汰策略有两种：<strong>定时删除</strong>和<strong>惰性删除</strong></p> <p>如果 Redis 采用的是主从架构，那么以上两种淘汰策略是基于 Redis 主库的，每当主库触发了淘汰策略，即会在 AOF 文件写入一个<code>del</code>命令，而从库的淘汰策略是基于主从同步来完成的</p> <p><strong>1、定时删除</strong></p> <p>Redis 将每个设置了过期时间的 key 放到一个独立的 Hash 表中，默认每秒定时遍历这个 hash 而不是整个 Redis 内存空间，并且 Redis 不会遍历所有的 key，而是采用一种贪心策略。步骤如下：</p> <p>1）从过期 key 字典中，随机找20个 key；</p> <p>2）删除 20 个 key 中过期的 key；</p> <p>3）如果 2 中过期的 key 超过 1/4，则重复第一步</p> <blockquote><p>如果有大量的key在同一时间段内过期，就会造成数据库的集中访问，就是<strong>缓存雪崩</strong></p></blockquote> <p><strong>2、惰性删除</strong></p> <p>因为定时删除会漏掉一部分已过期的 key 而没有被删除，所以 Redis 引入一个惰性删除来删除那些漏掉了的 key。客户端访问的时候，会对这个 key 的过期时间进行检查，如果过期了就立即删除</p> <h3 id="内存淘汰机制-redis-内存满触发"><a href="#内存淘汰机制-redis-内存满触发" class="header-anchor">#</a> 内存淘汰机制（Redis 内存满触发）</h3> <blockquote><p>如果定期删除漏掉了大量的 key，且后面也没有访问这些 key，没有触发惰性删除，那么内存中会残留大量垃圾 key。直到某一个时刻，Redis 内存总会被填满，此时 Redis 会触发内存淘汰机制</p></blockquote> <p>Redis 配置文件中可以设置 maxmemory，内存的最大使用量，到达限度时会执行<code>内存淘汰机制</code>。没有配置时，<code>默认为no-eviction</code></p> <table><thead><tr><th>名称</th> <th>描述</th></tr></thead> <tbody><tr><td>volatile-lru</td> <td>从<code>已设置过期时间</code>的数据集中挑选<code>最近最少使用</code>的数据淘汰</td></tr> <tr><td>volatile-lfu</td> <td>从<code>已设置过期时间</code>的数据集中挑选<code>最不经常使用</code>的数据淘汰</td></tr> <tr><td>volatile-ttl</td> <td>从<code>已设置过期时间</code>的数据集中挑选<code>将要过期</code>的数据淘汰</td></tr> <tr><td>volatile-random</td> <td>从<code>已设置过期时间</code>的数据集中挑选<code>任意</code>的数据淘汰</td></tr> <tr><td>allkeys-lru</td> <td>当<code>内存不足写入新数据</code>时，淘汰<code>最近最少使用</code>的Key</td></tr> <tr><td>allkeys-lfu</td> <td>当<code>内存不足写入新数据</code>时，淘汰<code>最不经常使用</code>的Key</td></tr> <tr><td>allkeys-random</td> <td>当<code>内存不足写入新数据</code>时，淘汰<code>随机选择</code>的Key</td></tr> <tr><td>no-eviction</td> <td>当<code>内存不足写入新数据</code>时，写入操作会报错，同时不删除数据</td></tr></tbody></table> <h2 id="渐进式-rehash"><a href="#渐进式-rehash" class="header-anchor">#</a> 渐进式 Rehash</h2> <p>在 Redis 中，键值对（Key-Value）存储方式是由<strong>字典（Dict）<strong>保存的，而字典底层是通过</strong>哈希表</strong>来实现的。通过哈希表中的节点保存字典中的键值对。我们知道当 HashMap 中发生 Hash 冲突时，出于链表性能的考虑，会进行 Resize 的操作。Redis 也一样。</p> <p>在 Redis 的具体实现中，使用了一种叫做 <strong>渐进式哈希（Rehash）</strong> 的机制来提高字典的缩放效率，避免 rehash 对服务器性能造成影响。==假如 Redis 中有大量的 key，一次性对全部的数据进行 Rehash，可能会导致 Redis 在一段时间内停止服务==。</p> <blockquote><p>在Redis中，哈希表扩容需要将 <code>哈希表0</code> 里面的所有键值对 rehash 到 <code>哈希表1</code> 里面， 但是这个 rehash 动作并不是一次性完成的， 而是分多次、渐进式地完成的</p></blockquote> <p><strong>rehash 步骤</strong></p> <ol><li>为 <code>哈希表1</code> 分配空间，且空间大小为<code>哈希表0</code>的两倍， 让字典同时持有 <code>哈希表0</code> 和 <code>哈希表1</code> 两个哈希表</li> <li>在字典中维持一个索引计数器变量 <code>rehashidx</code>（即哈希表的下标） ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始</li> <li>在 rehash 进行期间， <strong>每次对字典执行 CRUD 操作时</strong>， 程序除了执行指定的操作以外， 还会顺带将 <code>哈希表0</code> 在 rehashidx 索引上的键值对 rehash，并放到 <code>哈希表1</code> 。 当 rehash 工作完成之后， 程序将 rehashidx 属性的值+1</li> <li>随着字典操作的不断执行， <code>哈希表0</code> 的所有键值对都会被 rehash 至 <code>哈希表1</code> ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。</li></ol> <p><strong>rehash 期间的 CRUD 操作</strong></p> <p>因为在进行渐进式 rehash 的过程中， 字典会同时使用  <code>哈希表0</code> 和 <code>哈希表1</code> 两个哈希表， 所以在渐进式 rehash 进行期间， <strong>字典的CRUD操作会在两个哈希表上进行</strong>。比如要在字典里面查找一个键的话， 程序会先在  <code>哈希表0</code> 里面进行查找， 如果没找到的话， 就会继续到 <code>哈希表1</code> 里面进行查找， 诸如此类。</p> <p>另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 <code>哈希表1</code> 里面， 而 <code>哈希表0</code>则不再进行任何添加操作： 这一措施保证了 <code>哈希表0</code> 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表</p> <p><strong>rehash 带来的问题</strong></p> <p>渐进式 rehash 避免了 Redis 阻塞，可以说非常完美。但是由于在 rehash 时需要分配一个新的 hash 表，在 rehash 期间，同时有两个 hash 表在使用，会使得 redis 内存使用量瞬间突增。如果当前 Redis 结点的内存占用量达到maxmemory，会触发内存淘汰机制，导致大量的 Key 被驱逐</p> <h2 id="分布式锁"><a href="#分布式锁" class="header-anchor">#</a> 分布式锁</h2> <h3 id="mysql和redis双写-读写不一致"><a href="#mysql和redis双写-读写不一致" class="header-anchor">#</a> MySQL和Redis双写/读写不一致</h3> <blockquote><p>在大的并发下，同时操作数据库与缓存会存在数据不一致性问题</p></blockquote> <p><strong>双写不一致</strong></p> <img src="/assets/img/image-20210810141933541.28f6299e.png" alt="image-20210810141933541" style="zoom:67%;"> <p><strong>读写不一致</strong></p> <p><img src="/assets/img/image-20210810142733895.9213ae49.png" alt="image-20210810142733895"></p> <p><strong>解决方案</strong></p> <ol><li>对于并发几率很小的数据（如个人维度的订单数据、用户数据等)，这种几乎不用考虑这个问题，很少会发生缓存不一致，可以给缓存数据加上过期时间，每隔一段时间触发读的主动更新即可。</li> <li>并发很高，如果业务上能容忍短时间的缓存数据不一致（如商品名称，商品分类菜单等），缓存加上过期时间依然可以解决大部分业务对于缓存的要求。</li> <li>如果不能容忍缓存数据不一致，可以通过<strong>加读写锁</strong>保证并发读写或写写的时候按顺序排好队，读读的时候相当于无锁</li> <li>也可以用阿里开源的<strong>canal</strong>通过监听数据库的<strong>binlog日志</strong>及时的去修改缓存，但是引入了新的中间件，增加了系统的复杂度</li></ol> <blockquote><p>canal 的工作原理就是把自己<strong>伪装成 MySQL slave</strong>，模拟 MySQL slave 的交互协议向 MySQL Mater 发送 dump 协议，MySQL mater 收到 canal 发送过来的 dump 请求，开始推送 binary log 给 canal，然后 canal 解析 binary log，再发送到存储目的地。</p></blockquote> <p>以上我们针对的都是<strong>读多写少</strong>的情况加入缓存提高性能，==如果<strong>写多读多</strong>的情况又不能容忍缓存数据不一致，那就没必要加缓存了，可以直接操作数据库==。放入缓存的数据应该是对实时性、一致性要求不是很高的数据。</p> <h3 id="分布式锁实现"><a href="#分布式锁实现" class="header-anchor">#</a> 分布式锁实现</h3> <blockquote><p>4种实现方式</p></blockquote> <p>1、<strong>利用 setnx + expire 命令 (错误的做法)</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span><span class="token class-name">String</span> requset<span class="token punctuation">,</span><span class="token keyword">int</span> timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Long</span> result <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">setnx</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> requset<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// result = 1时，设置成功，否则设置失败</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token number">1L</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> jedis<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1L</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>setnx 和 expire 是分开的两步操作，不具有原子性，如果执行完第一条指令应用异常或者重启了，锁将无法过期。一种改善方案就是使用 Lua 脚本来保证原子性（包含 setnx 和 expire 两条指令）</p> <p>2、<strong>使用Lua脚本（包含 setnx 和 expire 两条指令）</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock_with_lua</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">String</span> <span class="token class-name">UniqueId</span><span class="token punctuation">,</span> <span class="token keyword">int</span> seconds<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> lua_scripts <span class="token operator">=</span> <span class="token string">&quot;if redis.call('setnx',KEYS[1],ARGV[1]) == 1 then&quot;</span> <span class="token operator">+</span>
            <span class="token string">&quot;redis.call('expire',KEYS[1],ARGV[2]) return 1 else return 0 end&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> keys <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> values <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    keys<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    values<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">UniqueId</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    values<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>seconds<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Object</span> result <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span>lua_scripts<span class="token punctuation">,</span> keys<span class="token punctuation">,</span> values<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//判断是否成功</span>
    <span class="token keyword">return</span> result<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>3、<strong>使用<code>set key value [EX seconds][PX milliseconds][NX|XX]</code>命令 (正确做法)</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>SET key value<span class="token punctuation">[</span>EX seconds<span class="token punctuation">]</span><span class="token punctuation">[</span>PX milliseconds<span class="token punctuation">]</span><span class="token punctuation">[</span>NX<span class="token operator">|</span>XX<span class="token punctuation">]</span>
<span class="token comment"># EX seconds: 设定过期时间，单位为秒</span>
<span class="token comment"># PX milliseconds: 设定过期时间，单位为毫秒</span>
<span class="token comment"># NX: 仅当key不存在时设置值</span>
<span class="token comment"># XX: 仅当key存在时设置值</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>4、<strong>Redlock算法 与 Redisson 实现</strong></p> <p><strong>参考</strong></p> <p><a href="https://www.jianshu.com/p/c2841d65df4c" target="_blank" rel="noopener noreferrer">死磕Redis5.0之跳跃表)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://mp.weixin.qq.com/s/Pc8GWsRbqpnUC6ExMXtX9g" target="_blank" rel="noopener noreferrer">Redis(2)——跳跃表<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://www.cnblogs.com/hunternet/p/11248192.html" target="_blank" rel="noopener noreferrer">Redis数据结构——跳跃表 - Mr于 - 博客园 (cnblogs.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/6991080701365846046" target="_blank" rel="noopener noreferrer">Redis系列-我用1W字总结了所有的点，确定不了解一下吗？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/6844903830442737671" target="_blank" rel="noopener noreferrer">基于Redis的分布式锁实现<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/6844904134764658702" target="_blank" rel="noopener noreferrer">部门老大：redis 分布式锁再这么用，我就劝退你<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">last Updated:</span> <span class="time">10/26/2021, 9:40:23 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/database/MySQL.html" class="prev">
        MySQL
      </a></span> <!----></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.4235ef92.js" defer></script><script src="/assets/js/2.56b23ebb.js" defer></script><script src="/assets/js/8.278983a5.js" defer></script>
  </body>
</html>
